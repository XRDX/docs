

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ECMAScript 6 介绍 &mdash; JS 教程 beta 文档</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="DOM 模型" href="../dom/index.html" />
    <link rel="prev" title="严格模式" href="strict.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> JS 教程
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/index.html">导论</a></li>
<li class="toctree-l1"><a class="reference internal" href="../grammar/index.html">基本语法</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stdlib/index.html">stdlib 标准库</a></li>
<li class="toctree-l1"><a class="reference internal" href="../oop/index.html">面向对象编程</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">语法专题</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="single-thread.html">异步操作概述</a></li>
<li class="toctree-l2"><a class="reference internal" href="timer.html">定时器</a></li>
<li class="toctree-l2"><a class="reference internal" href="promise.html">Promise 对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">严格模式</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">ECMAScript 6 介绍</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#">概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ecmascript-6">使用ECMAScript 6的方法</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#">安装</a></li>
<li class="toctree-l2"><a class="reference internal" href="#es6">运行ES6文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="#es6es5">将ES6文件转为ES5文件</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#">数据类型</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#let">let命令</a></li>
<li class="toctree-l4"><a class="reference internal" href="#const">const命令</a></li>
<li class="toctree-l4"><a class="reference internal" href="#set">Set数据结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="#map">Map数据结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rest">rest（...）运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="#iterator">遍历器（Iterator）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#generator">generator 函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">原生对象的扩展</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#">语法糖</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#">二进制和八进制表示法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">增强的对象写法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#arrow">箭头函数（arrow）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">函数参数的默认值</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">模板字符串</a></li>
<li class="toctree-l4"><a class="reference internal" href="#for-of">for...of循环</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">数组推导</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">多变量赋值</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#">数据结构</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#class">class结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module">module定义</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ecmascript-7">ECMAScript 7</a></li>
<li class="toctree-l3"><a class="reference internal" href="#">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../dom/index.html">DOM 模型</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bom/index.html">BOM 浏览器环境</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">JS 教程</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">语法专题</a> &raquo;</li>
        
      <li>ECMAScript 6 介绍</li>
    
    

  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="ecmascript-6">
<span id="ecmascript-6"></span><h1>ECMAScript 6 介绍<a class="headerlink" href="#ecmascript-6" title="永久链接至标题">¶</a></h1>
<div class="section" id="">
<span id="id1"></span><h2>概述<a class="headerlink" href="#" title="永久链接至标题">¶</a></h2>
<p>ECMAScript 6 是JavaScript的下一代标准，正处在快速开发之中，大部分已经完成了，预计将在2014年正式发布。Mozilla将在这个标准的基础上，推出JavaScript 2.0。</p>
<p>ECMAScript 6的目标，是使得JavaScript可以用来编写复杂的应用程序、函数库和代码的自动生成器（code generator）。</p>
<p>最新的浏览器已经部分支持ECMAScript 6 的语法，可以通过<a class="reference external" href="http://kangax.github.io/es5-compat-table/es6/">《ECMAScript 6 浏览器兼容表》</a>查看浏览器支持情况。</p>
<p>下面对ECMAScript 6新增的语法特性逐一介绍。由于ECMAScript 6的正式标准还未出台，所以以下内容随时可能发生变化，不一定是最后的版本。</p>
</div>
<div class="section" id="ecmascript-6">
<span id="id2"></span><h2>使用ECMAScript 6的方法<a class="headerlink" href="#ecmascript-6" title="永久链接至标题">¶</a></h2>
<p>目前，V8引擎已经部署了ECMAScript 6的部分特性。使用node.js 0.11版，就可以体验这些特性。</p>
<p>node.js 0.11版的一种比较方便的使用方法，是使用版本管理工具<a class="reference external" href="https://github.com/creationix/nvm">nvm</a>。下载nvm以后，进入项目目录，运行下面的命令，激活nvm。</p>
<p>{% highlight bash %}</p>
<p>source nvm.sh</p>
<p>{% endhighlight %}</p>
<p>然后，指定node运行版本。</p>
<p>{% highlight bash %}</p>
<p>nvm use 0.11</p>
<p>{% endhighlight %}</p>
<p>最后，用--harmony参数进入node运行环境，就可以在命令行下体验ECMAScript 6了。</p>
<p>{% highlight bash %}</p>
<p>node --harmony</p>
<p>{% endhighlight %}</p>
<p>另外，可以使用Google的<a class="reference external" href="https://github.com/google/traceur-compiler">Traceur</a>（<a class="reference external" href="http://google.github.io/traceur-compiler/demo/repl.html">在线转换工具</a>），将ES6代码编译为ES5。</p>
<p>{% highlight bash %}</p>
</div>
</div>
<div class="section" id="">
<span id="id3"></span><h1>安装<a class="headerlink" href="#" title="永久链接至标题">¶</a></h1>
<p>npm install -g traceur</p>
</div>
<div class="section" id="es6">
<span id="es6"></span><h1>运行ES6文件<a class="headerlink" href="#es6" title="永久链接至标题">¶</a></h1>
<p>traceur /path/to/es6</p>
</div>
<div class="section" id="es6es5">
<span id="es6es5"></span><h1>将ES6文件转为ES5文件<a class="headerlink" href="#es6es5" title="永久链接至标题">¶</a></h1>
<p>traceur --script /path/to/es6 --out /path/to/es5</p>
<p>{% endhighlight %}</p>
<div class="section" id="">
<span id="id4"></span><h2>数据类型<a class="headerlink" href="#" title="永久链接至标题">¶</a></h2>
<div class="section" id="let">
<span id="let"></span><h3>let命令<a class="headerlink" href="#let" title="永久链接至标题">¶</a></h3>
<p><strong>（1）概述</strong></p>
<p>ECMAScript 6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p>
<p>{% highlight javascript %}</p>
<p>{
let a = 10;
var b = 1;
}</p>
<p>a // ReferenceError: a is not defined.
b //1</p>
<p>{% endhighlight %}</p>
<p>上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。</p>
<p>下面的代码如果使用var，最后输出的是9。</p>
<p>{% highlight javascript %}</p>
<p>var a = [];
for (var i = 0; i &lt; 10; i++) {
var c = i;
a[i] = function () {
console.log(c);
};
}
a<a class="reference external" href="#">6</a>; // 9</p>
<p>{% endhighlight %}</p>
<p>如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。</p>
<p>{% highlight javascript %}</p>
<p>var a = [];
for (var i = 0; i &lt; 10; i++) {
let c = i;
a[i] = function () {
console.log(c);
};
}
a<a class="reference external" href="#">6</a>; // 6</p>
<p>{% endhighlight %}</p>
<p>注意，let不允许在相同作用域内，重复声明同一个变量。</p>
<p>{% highlight javascript %}</p>
<p>// 报错
{
let a = 10;
var a = 1;
}</p>
<p>// 报错
{
let a = 10;
let a = 1;
}</p>
<p>{% endhighlight %}</p>
<p><strong>（2）块级作用域</strong></p>
<p>let实际上为JavaScript新增了块级作用域。</p>
<p>{% highlight javascript %}</p>
<p>function f1() {
let n = 5;
if (true) {
let n = 10;
}
console.log(n); // 5
}</p>
<p>{% endhighlight %}</p>
<p>上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。如果使用var定义变量n，最后输出的值就是10。</p>
<p>块级作用域的出现，实际上使得获得广泛应用的立即执行函数（IIFE）不再必要了。</p>
<p>{% highlight javascript %}</p>
<p>// IIFE写法
(function () {
var tmp = ...;
...
}());</p>
<p>// 块级作用域写法
{
let tmp = ...;
...
}</p>
<p>{% endhighlight %}</p>
<p><strong>（3）不存在变量提升</strong></p>
<p>需要注意的是，let声明的变量不存在“变量提升”现象。</p>
<p>{% highlight javascript %}</p>
<p>console.log(x);
let x = 10;</p>
<p>{% endhighlight %}</p>
<p>上面代码运行后会报错，表示x没有定义。如果用var声明x，就不会报错，输出结果为undefined。</p>
</div>
<div class="section" id="const">
<span id="const"></span><h3>const命令<a class="headerlink" href="#const" title="永久链接至标题">¶</a></h3>
<p>const也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。</p>
<p>{% highlight javascript %}</p>
<p>const PI = 3.1415;</p>
<p>PI
// 3.1415</p>
<p>PI = 3;</p>
<p>PI
// 3.1415</p>
<p>const PI = 3.1;</p>
<p>PI
// 3.1415</p>
<p>{% endhighlight %}</p>
<p>上面代码表明改变常量的值是不起作用的。需要注意的是，对常量重新赋值不会报错，只会默默地失败。</p>
<blockquote>
<div>const的作用域与var命令相同：如果在全局环境声明，常量就在全局环境有效；如果在函数内声明，常量就在函数体内有效。</div></blockquote>
</div>
<div class="section" id="set">
<span id="set"></span><h3>Set数据结构<a class="headerlink" href="#set" title="永久链接至标题">¶</a></h3>
<p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<p>Set本身是一个构造函数，用来生成Set数据结构。</p>
<p>{% highlight javascript %}</p>
<p>var s = new Set();</p>
<p>[2,3,5,4,5,2,2].map(x =&gt; s.add(x))
for (i of s) {console.log(i)}
// 2 3 4 5</p>
<p>{% endhighlight %}</p>
<p>上面代码表示，set数据结构不会添加重复的值。</p>
<p>set数据结构有以下属性和方法：</p>
<ul class="simple">
<li>size：返回成员总数。</li>
<li>add(value)：添加某个值。</li>
<li>delete(value)：删除某个值。</li>
<li>has(value)：返回一个布尔值，表示该值是否为set的成员。</li>
<li>clear()：清除所有成员。</li>
</ul>
<p>{% highlight javascript %}</p>
<p>s.add(&quot;1&quot;).add(&quot;2&quot;).add(&quot;2&quot;);
// 注意“2”被加入了两次</p>
<p>s.size // 2</p>
<p>s.has(&quot;1&quot;)    // true
s.has(&quot;2&quot;)    // true
s.has(&quot;3&quot;)   // false</p>
<p>s.delete(&quot;2&quot;);
s.has(&quot;2&quot;)    // false</p>
<p>{% endhighlight %}</p>
</div>
<div class="section" id="map">
<span id="map"></span><h3>Map数据结构<a class="headerlink" href="#map" title="永久链接至标题">¶</a></h3>
<p>ES6还提供了map数据结构。它类似于对象，就是一个键值对的集合，但是“键”的范围不限于字符串，甚至对象也可以当作键。</p>
<p>{% highlight javascript %}</p>
<p>var m = new Map();</p>
<p>o = {p: &quot;Hello World&quot;};
m.set(o, &quot;content&quot;)
console.log(m.get(o))
// &quot;content&quot;</p>
<p>{% endhighlight %}</p>
<p>上面代码将一个对象当作m的一个键。</p>
<p>Map数据结构有以下属性和方法。</p>
<ul class="simple">
<li>size：返回成员总数。</li>
<li>set(key, value)：设置一个键值对。</li>
<li>get(key)：读取一个键。</li>
<li>has(key)：返回一个布尔值，表示某个键是否在Map数据结构中。</li>
<li>delete(key)：删除某个键。</li>
<li>clear()：清除所有成员。</li>
</ul>
<p>{% highlight javascript %}</p>
<p>var m = new Map();</p>
<p>m.set(&quot;edition&quot;, 6)        // 键是字符串
m.set(262, &quot;standard&quot;)     // 键是数值
m.set(undefined, &quot;nah&quot;)    // 键是undefined</p>
<p>var hello = function() {console.log(&quot;hello&quot;);}
m.set(hello, &quot;Hello ES6!&quot;) // 键是函数</p>
<p>m.has(&quot;edition&quot;)     // true
m.has(&quot;years&quot;)       // false
m.has(262)           // true
m.has(undefined)     // true
m.has(hello)         // true</p>
<p>m.delete(undefined)
m.has(undefined)       // false</p>
<p>m.get(hello)  // Hello ES6!
m.get(&quot;edition&quot;)  // 6</p>
<p>{% endhighlight %}</p>
</div>
<div class="section" id="rest">
<span id="rest"></span><h3>rest（...）运算符<a class="headerlink" href="#rest" title="永久链接至标题">¶</a></h3>
<p><strong>（1）基本用法</strong></p>
<p>ES6引入rest运算符（...），用于获取函数的多余参数，这样就不需要使用arguments.length了。rest运算符后面是一个数组变量，该变量将多余的参数放入数组中。</p>
<p>{% highlight javascript %}</p>
<p>function add(...values) {
let sum = 0;</p>
<p>for (var val of values) {
sum += val;
}</p>
<p>return sum;
}</p>
<p>add(2, 5, 3) // 10</p>
<p>{% endhighlight %}</p>
<p>上面代码的add函数是一个求和函数，利用rest运算符，可以向该函数传入任意数目的参数。</p>
<p>下面是一个利用rest运算符改写数组push方法的例子。</p>
<p>{% highlight javascript %}</p>
<p>function push(array, ...items) {
items.forEach(function(item) {
array.push(item);
console.log(item);
});
}</p>
<p>var a = [];
push(a, &quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;, &quot;a4&quot;);</p>
<p>{% endhighlight %}</p>
<p><strong>（2）将数组转为参数序列</strong></p>
<p>rest运算符不仅可以用于函数定义，还可以用于函数调用。</p>
<p>{% highlight javascript %}</p>
<p>function f(s1, s2, s3, s4, s5) {
console.log(s1 + s2 + s3 + s4 +s5);
}</p>
<p>var a = [&quot;a2&quot;, &quot;a3&quot;, &quot;a4&quot;, &quot;a5&quot;];</p>
<p>f(&quot;a1&quot;, ...a)
// a1a2a3a4a5</p>
<p>{% endhighlight %}</p>
<p>从上面的例子可以看出，rest运算符的另一个重要作用是，可以将数组转变成正常的参数序列。利用这一点，可以简化求出一个数组最大元素的写法。</p>
<p>{% highlight javascript %}</p>
<p>// ES5
Math.max.apply(null, [14, 3, 77])</p>
<p>// ES6
Math.max(...[14, 3, 77])</p>
<p>// 等同于
Math.max(14, 3, 77);</p>
<p>{% endhighlight %}</p>
<p>上面代码表示，由于JavaScript不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了rest运算符以后，就可以直接用Math.max了。</p>
</div>
<div class="section" id="iterator">
<span id="iterator"></span><h3>遍历器（Iterator）<a class="headerlink" href="#iterator" title="永久链接至标题">¶</a></h3>
<p>遍历器（Iterator）是一种协议，任何对象都可以部署遍历器协议，从而使得for...of循环可以遍历这个对象。</p>
<p>遍历器协议规定，任意对象只要部署了next方法，就可以作为遍历器，但是next方法必须返回一个包含value和done两个属性的对象。其中，value属性当前遍历位置的值，done属性是一个布尔值，表示遍历是否结束。</p>
<p>{% highlight javascript %}</p>
<p>function makeIterator(array){
var nextIndex = 0;</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>return {
   next: function(){
       return nextIndex &lt; array.length ?
           {value: array[nextIndex++], done: false} :
           {done: true};
   }
}
</pre></div>
</div>
<p>}</p>
<p>var it = makeIterator(['a', 'b']);</p>
<p>it.next().value // 'a'
it.next().value // 'b'
it.next().done  // true</p>
<p>{% endhighlight %}</p>
<p>下面是一个无限运行的遍历器的例子。</p>
<p>{% highlight javascript %}</p>
<p>function idMaker(){
var index = 0;</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="p">{</span>
   <span class="nb">next</span><span class="p">:</span> <span class="n">function</span><span class="p">(){</span>
       <span class="k">return</span> <span class="p">{</span><span class="n">value</span><span class="p">:</span> <span class="n">index</span><span class="o">++</span><span class="p">,</span> <span class="n">done</span><span class="p">:</span> <span class="n">false</span><span class="p">};</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>}</p>
<p>var it = idMaker();</p>
<p>it.next().value // '0'
it.next().value // '1'
it.next().value // '2'
// ...</p>
<p>{% endhighlight %}</p>
</div>
<div class="section" id="generator">
<span id="generator"></span><h3>generator 函数<a class="headerlink" href="#generator" title="永久链接至标题">¶</a></h3>
<p>上一部分的遍历器，用来依次取出集合中的每一个成员，但是某些情况下，我们需要的是一个内部状态的遍历器。也就是说，每调用一次遍历器，对象的内部状态发生一次改变（可以理解成发生某些事件）。ECMAScript 6 引入了generator函数，作用就是返回一个内部状态的遍历器，主要特征是函数内部使用了yield语句。</p>
<p>当调用generator函数的时候，该函数并不执行，而是返回一个遍历器（可以理解成暂停执行）。以后，每次调用这个遍历器的next方法，就从函数体的头部或者上一次停下来的地方开始执行（可以理解成恢复执行），直到遇到下一个yield语句为止，并返回该yield语句的值。</p>
<p>ECMAScript 6草案定义的generator函数，需要在function关键字后面，加一个星号。然后，函数内部使用yield语句，定义遍历器的每个成员。</p>
<p>{% highlight javascript %}</p>
<p>function* helloWorldGenerator() {
yield 'hello';
yield 'world';
}</p>
<p>{% endhighlight %}</p>
<p>yield有点类似于return语句，都能返回一个值。区别在于每次遇到yield，函数返回紧跟在yield后面的那个表达式的值，然后暂停执行，下一次从该位置继续向后执行，而return语句不具备位置记忆的功能。</p>
<p>上面代码定义了一个generator函数helloWorldGenerator，它的遍历器有两个成员“hello”和“world”。调用这个函数，就会得到遍历器。</p>
<p>{% highlight javascript %}</p>
<p>var hw = helloWorldGenerator();</p>
<p>{% endhighlight %}</p>
<p>执行遍历器的next方法，则会依次遍历每个成员。</p>
<p>{% highlight javascript %}</p>
<p>hw.next()
// { value: 'hello', done: false }</p>
<p>hw.next()
// { value: 'world', done: false }</p>
<p>hw.next()
// { value: undefined, done: true }</p>
<p>hw.next()
// Error: Generator has already finished
//  at GeneratorFunctionPrototype.next (native)
//  at repl:1:3
//  at REPLServer.defaultEval (repl.js:129:27)
//  ...</p>
<p>{% endhighlight %}</p>
<p>上面代码一共调用了四次next方法。</p>
<ul class="simple">
<li>第一次调用：函数开始执行，直到遇到第一句yield语句为止。next方法返回一个对象，它的value属性就是当前yield语句的值hello，done属性的值false，表示遍历还没有结束。</li>
<li>第二次调用：函数从上次yield语句停下的地方，一直执行到下一个yield语句。next方法返回一个对象，它的value属性就是当前yield语句的值world，done属性的值false，表示遍历还没有结束。</li>
<li>第三次调用：函数从上次yield语句停下的地方，一直执行到函数结束。next方法返回一个对象，它的value属性就是函数最后的返回值，由于上例的函数没有return语句（即没有返回值），所以value属性的值为undefined，done属性的值true，表示遍历已经结束。</li>
<li>第四次调用：由于此时函数已经运行完毕，next方法直接抛出一个错误。</li>
</ul>
<p>遍历器的本质，其实是使用yield语句暂停执行它后面的操作，当调用next方法时，再继续往下执行，直到遇到下一个yield语句，并返回该语句的值，如果直到运行结束。</p>
<p>如果next方法带一个参数，该参数就会被当作上一个yield语句的返回值。</p>
<p>{% highlight javascript %}</p>
<p>function* f() {
for(var i=0; true; i++) {
var reset = yield i;
if(reset) { i = -1; }
}
}</p>
<p>var g = f();</p>
<p>g.next() // { value: 0, done: false }
g.next() // { value: 1, done: false }
g.next(true) // { value: 0, done: false }</p>
<p>{% endhighlight %}</p>
<p>上面代码先定义了一个可以无限运行的generator函数f，如果next方法没有参数，正常情况下返回一个递增的i；如果next方法有参数，则上一次yield语句的返回值将会等于该参数。如果该参数为true，则会重置i的值。</p>
<p>generator函数的这种暂停执行的效果，意味着可以把异步操作写在yield语句里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield语句下面，反正要等到调用next方法时再执行。所以，generator函数的一个重要实际意义就是用来处理异步操作，改写回调函数。</p>
<p>{% highlight javascript %}</p>
<p>function* loadUI() {
showLoadingScreen();
yield loadUIDataAsynchronously();
hideLoadingScreen();
}</p>
<p>{% endhighlight %}</p>
<p>上面代码表示，第一次调用loadUI函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用next方法，则会显示登录窗口，并且异步加载数据。再一次使用next方法，则会隐藏登录窗口。可以看到，这种写法的好处是所有登录窗口的逻辑，都被封装在一个函数，按部就班非常清晰。</p>
<p>下面是一个利用generator函数，实现斐波那契数列的例子。</p>
<p>{% highlight javascript %}</p>
<p>function* fibonacci() {
var previous = 0, current = 1;
while (true) {
var temp = previous;
previous = current;
current = temp + current;
yield current;
}
}</p>
<p>for (var i of fibonacci()) {
console.log(i);
}
// 1, 2, 3, 5, 8, 13, ...,</p>
<p>{% endhighlight %}</p>
<p>下面是利用for...of语句，对斐波那契数列的另一种实现。</p>
<p>{% highlight javascript %}</p>
<p>function* fibonacci() {
let [prev, curr] = [0, 1];
for (;;) {
[prev, curr] = [curr, prev + curr];
yield curr;
}
}</p>
<p>for (n of fibonacci()) {
if (n &gt; 1000) break;
console.log(n);
}</p>
<p>{% endhighlight %}</p>
<p>从上面代码可见，使用for...of语句时不需要使用next方法。</p>
<p>这里需要注意的是，yield语句运行的时候是同步运行，而不是异步运行（否则就失去了取代回调函数的设计目的了）。实际操作中，一般让yield语句返回Promises对象。</p>
<p>{% highlight javascript %}</p>
<p>var Q = require('q');</p>
<p>function delay(milliseconds) {
var deferred = Q.defer();
setTimeout(deferred.resolve, milliseconds);
return deferred.promise;
}</p>
<p>function *f(){
yield delay(100);
};</p>
<p>{% endhighlight %}</p>
<p>上面代码yield语句返回的就是一个Promises对象。</p>
<p>如果有一系列任务需要全部完成后，才能进行下一步操作，yield语句后面可以跟一个数组。下面就是一个例子。</p>
<p>{% highlight javascript %}</p>
<p>function *f() {
var urls = [
'http://example.com/',
'http://twitter.com/',
'http://bbc.co.uk/news/'
];
var arrayOfPromises = urls.map(someOperation);</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">arrayOfResponses</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">arrayOfPromises</span><span class="p">;</span>
 
<span class="n">this</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="s2">&quot;Results&quot;</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">urls</span><span class="o">.</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">this</span><span class="o">.</span><span class="n">body</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">urls</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; response length is &#39;</span>
          <span class="o">+</span> <span class="n">arrayOfResponses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">length</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>};</p>
<p>{% endhighlight %}</p>
</div>
<div class="section" id="">
<span id="id5"></span><h3>原生对象的扩展<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>ES6对JavaScript的原生对象，进行了扩展，提供了一系列新的属性和方法。</p>
<p>{% highlight javascript %}</p>
<p>Number.EPSILON
Number.isInteger(Infinity) // false
Number.isNaN(&quot;NaN&quot;) // false</p>
<p>Math.acosh(3) // 1.762747174039086
Math.hypot(3, 4) // 5
Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2</p>
<p>&quot;abcde&quot;.contains(&quot;cd&quot;) // true
&quot;abc&quot;.repeat(3) // &quot;abcabcabc&quot;</p>
<p>Array.from(document.querySelectorAll('*')) // Returns a real Array
Array.of(1, 2, 3) // Similar to new Array(...), but without special one-arg behavior
[0, 0, 0].fill(7, 1) // [0,7,7]
[1,2,3].findIndex(x =&gt; x == 2) // 1
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].entries() // iterator [0, &quot;a&quot;], [1,&quot;b&quot;], [2,&quot;c&quot;]
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].keys() // iterator 0, 1, 2
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].values() // iterator &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</p>
<p>Object.assign(Point, { origin: new Point(0,0) })</p>
<p>{% endhighlight %}</p>
</div>
</div>
<div class="section" id="">
<span id="id6"></span><h2>语法糖<a class="headerlink" href="#" title="永久链接至标题">¶</a></h2>
<p>ECMAScript 6提供了很多JavaScript语法的便捷写法。</p>
<div class="section" id="">
<span id="id7"></span><h3>二进制和八进制表示法<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>ES6提供了二进制和八进制数值的新的写法，分别用前缀0b和0o表示。</p>
<p>{% highlight javascript %}</p>
<p>0b111110111 === 503 // true
0o767 === 503 // true</p>
<p>{% endhighlight %}</p>
</div>
<div class="section" id="">
<span id="id8"></span><h3>增强的对象写法<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>
<p>{% highlight javascript %}</p>
<p>var Person = {
name: '张三',
//等同于birth: birth
birth,
// 等同于hello: function ()...
hello() { console.log('我的名字是', this.name); }
};</p>
<p>{% endhighlight %}</p>
</div>
<div class="section" id="arrow">
<span id="arrow"></span><h3>箭头函数（arrow）<a class="headerlink" href="#arrow" title="永久链接至标题">¶</a></h3>
<p><strong>（1）定义</strong></p>
<p>ES6允许使用“箭头”（=&gt;）定义函数。</p>
<p>{% highlight javascript %}</p>
<p>var f = v =&gt; v;</p>
<p>{% endhighlight %}</p>
<p>上面的箭头函数等同于：</p>
<p>{% highlight javascript %}</p>
<p>var f = function(v) {
return v;
};</p>
<p>{% endhighlight %}</p>
<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>
<p>{% highlight javascript %}</p>
<p>var f = () =&gt; 5;
// 等同于
var f = function (){ return 5 };</p>
<p>var sum = (num1, num2) =&gt; num1 + num2;
// 等同于
var sum = function(num1, num2) {
return num1 + num2;
};</p>
<p>{% endhighlight %}</p>
<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。</p>
<p>{% highlight javascript %}</p>
<p>var sum = (num1, num2) =&gt; { return num1 + num2; }</p>
<p>{% endhighlight %}</p>
<p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。</p>
<p>{% highlight javascript %}</p>
<p>var getTempItem = id =&gt; ({ id: id, name: &quot;Temp&quot; });</p>
<p>{% endhighlight %}</p>
<p><strong>（2）实例：回调函数的简化</strong></p>
<p>箭头函数的一个用处是简化回调函数。</p>
<p>{% highlight javascript %}</p>
<p>// 正常函数写法
[1,2,3].map(function (x) {
return x * x;
});</p>
<p>// 箭头函数写法
[1,2,3].map(x =&gt; x * x);</p>
<p>{% endhighlight %}</p>
<p>另一个例子是</p>
<p>{% highlight javascript %}</p>
<p>// 正常函数写法
var result = values.sort(function(a, b) {
return a - b;
});</p>
<p>// 箭头函数写法
var result = values.sort((a, b) =&gt; a - b);</p>
<p>{% endhighlight %}</p>
<p><strong>（3）注意点</strong></p>
<p>箭头函数有几个使用注意点。</p>
<ul class="simple">
<li>函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象。</li>
<li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li>
<li>不可以使用arguments对象，该对象在函数体内不存在。</li>
</ul>
<p>关于this对象，下面的代码将它绑定定义时的对象。</p>
<p>{% highlight javascript %}</p>
<p>var handler = {</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">id</span><span class="p">:</span> <span class="s2">&quot;123456&quot;</span><span class="p">,</span>

<span class="n">init</span><span class="p">:</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">document</span><span class="o">.</span><span class="n">addEventListener</span><span class="p">(</span><span class="s2">&quot;click&quot;</span><span class="p">,</span>
            <span class="n">event</span> <span class="o">=&gt;</span> <span class="n">this</span><span class="o">.</span><span class="n">doSomething</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">type</span><span class="p">),</span> <span class="n">false</span><span class="p">);</span>
<span class="p">},</span>

<span class="n">doSomething</span><span class="p">:</span> <span class="n">function</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Handling &quot;</span> <span class="o">+</span> <span class="nb">type</span>  <span class="o">+</span> <span class="s2">&quot; for &quot;</span> <span class="o">+</span> <span class="n">this</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>};</p>
<p>{% endhighlight %}</p>
<p>上面代码的init和doSomething方法中，都使用了箭头函数，它们中的this都绑定handler对象。否则，doSomething方法内部的this对象就指向全局对象，运行时会报错。</p>
</div>
<div class="section" id="">
<span id="id9"></span><h3>函数参数的默认值<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>ECMAScript 6 允许为函数的参数设置默认值。</p>
<p>{% highlight javascript %}</p>
<p>function Point(x = 0, y = 0) {
this.x = x;
this.y = y;
}</p>
<p>var p = new Point();
// p = { x:0, y:0 }</p>
<p>{% endhighlight %}</p>
</div>
<div class="section" id="">
<span id="id10"></span><h3>模板字符串<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>模板字符串（template string）是增强版的字符串，即可以当作普通字符串使用，也可以在字符串中嵌入变量。它用反引号（`）标识。</p>
<p>{% highlight javascript %}</p>
<p>// 普通字符串
<code class="docutils literal notranslate"><span class="pre">In</span> <span class="pre">JavaScript</span> <span class="pre">'\n'</span> <span class="pre">is</span> <span class="pre">a</span> <span class="pre">line-feed.</span></code></p>
<p>// 多行字符串
<code class="docutils literal notranslate"><span class="pre">In</span> <span class="pre">JavaScript</span> <span class="pre">this</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">legal.</span></code></p>
<p>// 字符串中嵌入变量
var name = &quot;Bob&quot;, time = &quot;today&quot;;
<code class="docutils literal notranslate"><span class="pre">Hello</span> <span class="pre">${name},</span> <span class="pre">how</span> <span class="pre">are</span> <span class="pre">you</span> <span class="pre">${time}?</span></code></p>
<p>var x = 1;
var y = 2;
console.log(<code class="docutils literal notranslate"><span class="pre">${</span> <span class="pre">x</span> <span class="pre">}</span> <span class="pre">+</span> <span class="pre">${</span> <span class="pre">y</span> <span class="pre">}</span> <span class="pre">=</span> <span class="pre">${</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">y}</span></code>)
// &quot;1 + 2 = 3&quot;</p>
<p>{% endhighlight %}</p>
</div>
<div class="section" id="for-of">
<span id="for-of"></span><h3>for...of循环<a class="headerlink" href="#for-of" title="永久链接至标题">¶</a></h3>
<p>JavaScript原有的for...in循环，只能获得对象的键名，不能直接获取键值。ES6提供for...of循环，允许遍历获得键值。</p>
<p>{% highlight javascript %}</p>
<p>var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];
for (a in arr) {
console.log(a);
}
// 0
// 1
// 2
// 3</p>
<p>for (a of arr) {
console.log(a);
}
// a
// b
// c
// d</p>
<p>{% endhighlight %}</p>
<p>上面代码表明，for...in循环读取键名，for...of循环读取键值。</p>
<p>for...of循环还可以遍历对象。</p>
<p>{% highlight javascript %}</p>
<p>var es6 = {
edition: 6,
committee: &quot;TC39&quot;,
standard: &quot;ECMA-262&quot;
};</p>
<p>for (e in es6) {
console.log(e);
}
// edition
// committee
// standard</p>
<p>var engines = new Set([&quot;Gecko&quot;, &quot;Trident&quot;, &quot;Webkit&quot;, &quot;Webkit&quot;]);
for (var e of engines) {
console.log(e);
}
// Gecko
// Trident
// Webkit</p>
<p>var es6 = new Map();
es6.set(&quot;edition&quot;, 6);
es6.set(&quot;committee&quot;, &quot;TC39&quot;);
es6.set(&quot;standard&quot;, &quot;ECMA-262&quot;);
for (var [name, value] of es6) {
console.log(name + &quot;: &quot; + value);
}
// edition: 6
// committee: TC39
// standard: ECMA-262</p>
<p>{% endhighlight %}</p>
<p>上面代码一共包含三个例子，第一个是for...in循环的例子，后两个是for...of循环的例子。最后一个例子是同时遍历对象的键名和键值。</p>
</div>
<div class="section" id="">
<span id="id11"></span><h3>数组推导<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p><strong>（1）基本用法</strong></p>
<p>ES6提供简洁写法，允许直接通过现有数组生成新数组，这被称为数组推导（array comprehension）。</p>
<p>{% highlight javascript %}</p>
<p>var a1 = [1, 2, 3, 4];
var a2 = [i * 2 for (i of a1)];</p>
<p>a2 // [2, 4, 6, 8]</p>
<p>{% endhighlight %}</p>
<p>上面代码表示，通过for...of结构，数组a2直接在a1的基础上生成。</p>
<p>数组推导可以替代map和filter方法。</p>
<p>{% highlight javascript %}</p>
<p>[for (i of [1, 2, 3]) i * i];
// 等价于
[1, 2, 3].map(function (i) { return i * i });</p>
<p>[i for (i of [1,4,2,3,-8]) if (i &lt; 3)];
// 等价于
[1,4,2,3,-8].filter(function(i) { return i &lt; 3 });</p>
<p>{% endhighlight %}</p>
<p>上面代码说明，模拟map功能只要单纯的for...of循环就行了，模拟filter功能除了for...of循环，还必须加上if语句。</p>
<p><strong>（2）多重推导</strong></p>
<p>新引入的for...of结构，可以直接跟在表达式的前面或后面，甚至可以在一个数组推导中，使用多个for...of结构。</p>
<p>{% highlight javascript %}</p>
<p>var a1 = [&quot;x1&quot;, &quot;y1&quot;];
var a2 = [&quot;x2&quot;, &quot;y2&quot;];
var a3 = [&quot;x3&quot;, &quot;y3&quot;];</p>
<p>[(console.log(s + w + r)) for (s of a1) for (w of a2) for (r of a3)];
// x1x2x3
// x1x2y3
// x1y2x3
// x1y2y3
// y1x2x3
// y1x2y3
// y1y2x3
// y1y2y3</p>
<p>{% endhighlight %}</p>
<p>上面代码在一个数组推导之中，使用了三个for...of结构。</p>
<p>需要注意的是，数组推导的方括号构成了一个单独的作用域，在这个方括号中声明的变量类似于使用let语句声明的变量。</p>
<p><strong>（3）字符串推导</strong></p>
<p>由于字符串可以视为数组，因此字符串也可以直接用于数组推导。</p>
<p>{% highlight javascript %}</p>
<p>[c for (c of 'abcde') if (/[aeiou]/.test(c))].join('') // 'ae'</p>
<p>[c+'0' for (c of 'abcde')].join('') // 'a0b0c0d0e0'</p>
<p>{% endhighlight %}</p>
<p>上面代码使用了数组推导，对字符串进行处理。</p>
<p>上一部分的数组推导有一个缺点，就是新数组会立即在内存中生成。这时，如果原数组是一个很大的数组，将会非常耗费内存。</p>
</div>
<div class="section" id="">
<span id="id12"></span><h3>多变量赋值<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>ES6允许简洁地对多变量赋值。正常情况下，将数组元素赋值给多个变量，只能一次次分开赋值。</p>
<p>{% highlight javascript %}</p>
<p>var a = 1;
var b = 2;
var c = 3;</p>
<p>{% endhighlight %}</p>
<p>ES6允许写成下面这样。</p>
<p>{% highlight javascript %}</p>
<p>var [a, b, c] = [1, 2, 3];</p>
<p>{% endhighlight %}</p>
<p>本质上，这种写法属于模式匹配，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些嵌套数组的例子。</p>
<p>{% highlight javascript %}</p>
<p>var [foo, [[bar], baz]] = [1, [[2], 3]]</p>
<p>var [,,third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]</p>
<p>var [head, ...tail] = [1, 2, 3, 4]</p>
<p>{% endhighlight %}</p>
<p>它还可以接受默认值。</p>
<p>{% highlight javascript %}</p>
<p>var [missing = true] = [];
console.log(missing)
// true</p>
<p>var { x = 3 } = {};
console.log(x)
// 3</p>
<p>{% endhighlight %}</p>
<p>它不仅可以用于数组，还可以用于对象。</p>
<p>{% highlight javascript %}</p>
<p>var { foo, bar } = { foo: &quot;lorem&quot;, bar: &quot;ipsum&quot; };</p>
<p>foo // &quot;lorem&quot;
bar // &quot;ipsum&quot;</p>
<p>var o = {
p1: [
&quot;Hello&quot;,
{ p2: &quot;World&quot; }
]
};</p>
<p>var { a: [p1, { p2 }] } = o;</p>
<p>console.log(p1)
// &quot;Hello&quot;</p>
<p>console.log(p2)
// &quot;World&quot;</p>
<p>{% endhighlight %}</p>
<p>这种写法的用途很多。</p>
<p><strong>（1）交换变量的值。</strong></p>
<p>{% highlight javascript %}</p>
<p>[x, y] = [y, x];</p>
<p>{% endhighlight %}</p>
<p><strong>（2）从函数返回多个值。</strong></p>
<p>{% highlight javascript %}</p>
<p>function example() {
return [1, 2, 3];
}</p>
<p>var [a, b, c] = example();</p>
<p>{% endhighlight %}</p>
<p><strong>（3）函数参数的定义。</strong></p>
<p>{% highlight javascript %}</p>
<p>function f({p1, p2, p3}) {
// ...
}</p>
<p>{% endhighlight %}</p>
<p><strong>（4）函数参数的默认值。</strong></p>
<p>{% highlight javascript %}</p>
<p>jQuery.ajax = function (url, {
async = true,
beforeSend = function () {},
cache = true,
complete = function () {},
crossDomain = false,
global = true,
// ... more config
}) {
// ... do stuff
};</p>
<p>{% endhighlight %}</p>
</div>
</div>
<div class="section" id="">
<span id="id13"></span><h2>数据结构<a class="headerlink" href="#" title="永久链接至标题">¶</a></h2>
<div class="section" id="class">
<span id="class"></span><h3>class结构<a class="headerlink" href="#class" title="永久链接至标题">¶</a></h3>
<p><strong>（1）基本用法</strong></p>
<p>ES6提供了“类”（class）。此前，一般用构造函数模拟“类”。</p>
<p>{% highlight javascript %}</p>
<p>// ES5
var Language = function(config) {
this.name = config.name;
this.founder = config.founder;
this.year = config.year;
};</p>
<p>Language.prototype.summary = function() {
return this.name+&quot;由&quot;+this.founder+&quot;在&quot;+this.year+&quot;创造&quot;;
};</p>
<p>// ES6
class Language {
constructor(name, founder, year) {
this.name = name;
this.founder = founder;
this.year = year;
}</p>
<p>summary() {
return this.name+&quot;由&quot;+this.founder+&quot;在&quot;+this.year+&quot;创造&quot;;
}
}</p>
<p>{% endhighlight %}</p>
<p>在上面代码中，ES6用constructor方法，代替ES5的构造函数。</p>
<p><strong>（2）继承</strong></p>
<p>ES6的class结构还允许使用extends关键字，表示继承。</p>
<p>{% highlight javascript %}</p>
<p>class MetaLanguage extends Language {
constructor(x, y, z, version) {
super(x, y, z);
this.version = version;
}
summary() {
//...
super.summary();
}
}</p>
<p>{% endhighlight %}</p>
<p>上面代码的super方法，表示调用父类的构造函数。</p>
</div>
<div class="section" id="module">
<span id="module"></span><h3>module定义<a class="headerlink" href="#module" title="永久链接至标题">¶</a></h3>
<p><strong>（1）基本用法</strong></p>
<p>ES6允许定义模块。也就是说，允许一个JavaScript脚本文件调用另一个脚本文件。</p>
<p>假设有一个circle.js，它是一个单独模块。</p>
<p>{% highlight javascript %}</p>
<p>// circle.js</p>
<p>export function area(radius) {
return Math.PI * radius * radius;
}</p>
<p>export function circumference(radius) {
return 2 * Math.PI * radius;
}</p>
<p>{% endhighlight %}</p>
<p>然后，main.js引用这个模块。</p>
<p>{% highlight javascript %}</p>
<p>// main.js</p>
<p>import { area, circumference } from 'circle';</p>
<p>console.log(&quot;圆面积：&quot; + area(4));
console.log(&quot;圆周长：&quot; + circumference(14));</p>
<p>{% endhighlight %}</p>
<p>另一种写法是整体加载circle.js。</p>
<p>{% highlight javascript %}</p>
<p>// main.js</p>
<p>module circle from 'circle';</p>
<p>console.log(&quot;圆面积：&quot; + circle.area(4));
console.log(&quot;圆周长：&quot; + circle.circumference(14));</p>
<p>{% endhighlight %}</p>
<p><strong>（2）模块的继承</strong></p>
<p>一个模块也可以继承另一个模块。</p>
<p>{% highlight javascript %}</p>
<p>// circleplus.js</p>
<p>export * from 'circle';
export var e = 2.71828182846;
export default function(x) {
return Math.exp(x);
}</p>
<p>{% endhighlight %}</p>
<p>加载上面的模块。</p>
<p>{% highlight javascript %}</p>
<p>// main.js</p>
<p>module math from &quot;circleplus&quot;;
import exp from &quot;circleplus&quot;;
console.log(exp(math.pi);</p>
<p>{% endhighlight %}</p>
<p><strong>（3）模块的默认方法</strong></p>
<p>还可以为模块定义默认方法。</p>
<p>{% highlight javascript %}</p>
<p>// circleplus.js</p>
<p>export default function(x) {
return Math.exp(x);
}</p>
<p>{% endhighlight %}</p>
</div>
</div>
<div class="section" id="ecmascript-7">
<span id="ecmascript-7"></span><h2>ECMAScript 7<a class="headerlink" href="#ecmascript-7" title="永久链接至标题">¶</a></h2>
<p>2013年3月，ECMAScript 6的草案封闭，不再接受新功能了。新的功能将被加入ECMAScript 7。根据JavaScript创造者Brendan Eich的<a class="reference external" href="http://wiki.ecmascript.org/doku.php?id=harmony:harmony">设想</a>，ECMAScript 7将使得JavaScript更适于开发复杂的应用程序和函数库。</p>
<p>ECMAScript 7可能包括的功能有：</p>
<ul class="simple">
<li><strong>Object.observe</strong>：对象与网页元素的双向绑定，只要其中之一发生变化，就会自动反映在另一者上。</li>
<li><strong>Multi-Threading</strong>：多线程支持。目前，Intel和Mozilla有一个共同的研究项目RiverTrail，致力于让JavaScript多线程运行。预计这个项目的研究成果会被纳入ECMAScript标准。</li>
<li><strong>Traits</strong>：它将是“类”功能（class）的一个替代。通过它，不同的对象可以分享同样的特性。</li>
</ul>
<p>其他可能包括的功能还有：更精确的数值计算、改善的内存回收、增强的跨站点安全、类型化的更贴近硬件的（Typed, Low-level）操作、国际化支持（Internationalization Support）、更多的数据结构等等。</p>
</div>
<div class="section" id="">
<span id="id14"></span><h2>参考链接<a class="headerlink" href="#" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>Sayanee Basu, <a class="reference external" href="http://net.tutsplus.com/articles/news/ecmascript-6-today/">Use ECMAScript 6 Today</a></li>
<li>Ariya Hidayat, <a class="reference external" href="http://www.sencha.com/blog/toward-modern-web-apps-with-ecmascript-6/">Toward Modern Web Apps with ECMAScript 6</a></li>
<li>Nick Fitzgerald, <a class="reference external" href="http://fitzgeraldnick.com/weblog/50/">Destructuring Assignment in ECMAScript 6</a></li>
<li>jmar777, <a class="reference external" href="http://devsmash.com/blog/whats-the-big-deal-with-generators">What's the Big Deal with Generators?</a></li>
<li>Nicholas C. Zakas, <a class="reference external" href="http://www.nczonline.net/blog/2013/09/10/understanding-ecmascript-6-arrow-functions/">Understanding ECMAScript 6 arrow functions</a></li>
<li>Dale Schouten, <a class="reference external" href="http://html5hub.com/10-ecmascript-6-tricks-you-can-perform-right-now/">10 Ecmascript-6 tricks you can perform right now</a></li>
<li>Mozilla Developer Network, <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators">Iterators and generators</a></li>
<li>Steven Sanderson, <a class="reference external" href="http://blog.stevensanderson.com/2013/12/21/experiments-with-koa-and-javascript-generators/">Experiments with Koa and JavaScript Generators</a></li>
<li>Matt Baker, <a class="reference external" href="http://flippinawesome.org/2014/02/10/replacing-callbacks-with-es6-generators/">Replacing callbacks with ES6 Generators</a></li>
<li>Domenic Denicola, <a class="reference external" href="http://www.slideshare.net/domenicdenicola/es6-the-awesome-parts">ES6: The Awesome Parts</a></li>
<li>Casper Beyer, <a class="reference external" href="http://caspervonb.github.io/2014/03/05/ecmascript6-features-and-tools.html">ECMAScript 6 Features and Tools</a></li>
<li>Luke Hoban, <a class="reference external" href="https://github.com/lukehoban/es6features">ES6 features</a></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../dom/index.html" class="btn btn-neutral float-right" title="DOM 模型" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="strict.html" class="btn btn-neutral" title="严格模式" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Vic Wang.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'beta',
            LANGUAGE:'zh',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/GA.js"></script>
      <script type="text/javascript" src="../_static/googleAnalysis.js"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>