

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>运算符 &mdash; JS 教程 beta 文档</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="数据类型转换" href="conversion.html" />
    <link rel="prev" title="函数" href="function.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> JS 教程
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/index.html">导论</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">基本语法</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="basic.html">基本语法</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">数据类型</a></li>
<li class="toctree-l2"><a class="reference internal" href="number.html">数值</a></li>
<li class="toctree-l2"><a class="reference internal" href="string.html">字符串</a></li>
<li class="toctree-l2"><a class="reference internal" href="object.html">对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="array.html">数组</a></li>
<li class="toctree-l2"><a class="reference internal" href="function.html">函数</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">运算符</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#">加法运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#">基本规则</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">对象的相加</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#">算术运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#">余数运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">自增和自减运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">数值运算符，负数值运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">指数运算符</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#">赋值运算符</a></li>
<li class="toctree-l3"><a class="reference internal" href="#">比较运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#">字符串的比较</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">非字符串的比较</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">严格相等运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">相等运算符</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#">布尔运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#">取反运算符（!）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">且运算符（&amp;&amp;）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">或运算符（||）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">三元条件运算符（?:）</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#">位运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#">概述</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">二进制或运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">二进制与运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">二进制否运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">异或运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">左移运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">右移运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">带符号位的右移运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">开关作用</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#">其他运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#void">void 运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">逗号运算符</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#">运算顺序</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#">优先级</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">圆括号的作用</a></li>
<li class="toctree-l4"><a class="reference internal" href="#">左结合与右结合</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#">参考链接</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="conversion.html">数据类型转换</a></li>
<li class="toctree-l2"><a class="reference internal" href="error.html">错误处理机制</a></li>
<li class="toctree-l2"><a class="reference internal" href="style.html">编程风格</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../stdlib/index.html">stdlib 标准库</a></li>
<li class="toctree-l1"><a class="reference internal" href="../oop/index.html">面向对象编程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/index.html">语法专题</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dom/index.html">DOM 模型</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bom/index.html">BOM 浏览器环境</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">JS 教程</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">基本语法</a> &raquo;</li>
        
      <li>运算符</li>
    
    

  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="">
<span id="id1"></span><h1>运算符<a class="headerlink" href="#" title="永久链接至标题">¶</a></h1>
<p>运算符是处理数据的基本方法，用来从现有的值得到新的值。JavaScript 提供了多种运算符，本章逐一介绍这些运算符。</p>
<div class="section" id="">
<span id="id2"></span><h2>加法运算符<a class="headerlink" href="#" title="永久链接至标题">¶</a></h2>
<div class="section" id="">
<span id="id3"></span><h3>基本规则<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>加法运算符（<code class="docutils literal notranslate"><span class="pre">+</span></code>）是最常见的运算符，用来求两个数值的和。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// 2</span>
</pre></div>
</div>
<p>JavaScript 允许非数值的相加。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kc">true</span> <span class="o">+</span> <span class="kc">true</span> <span class="c1">// 2</span>
<span class="mi">1</span> <span class="o">+</span> <span class="kc">true</span> <span class="c1">// 2</span>
</pre></div>
</div>
<p>上面代码中，第一行是两个布尔值相加，第二行是数值与布尔值相加。这两种情况，布尔值都会自动转成数值，然后再相加。</p>
<p>比较特殊的是，如果是两个字符串相加，这时加法运算符会变成连接运算符，返回一个新的字符串，将两个原字符串连接在一起。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;a&#39;</span> <span class="o">+</span> <span class="s1">&#39;bc&#39;</span> <span class="c1">// &quot;abc&quot;</span>
</pre></div>
</div>
<p>如果一个运算子是字符串，另一个运算子是非字符串，这时非字符串会转成字符串，再连接在一起。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="o">+</span> <span class="s1">&#39;a&#39;</span> <span class="c1">// &quot;1a&quot;</span>
<span class="kc">false</span> <span class="o">+</span> <span class="s1">&#39;a&#39;</span> <span class="c1">// &quot;falsea&quot;</span>
</pre></div>
</div>
<p>加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）。由于加法运算符存在重载，可能执行两种运算，使用的时候必须很小心。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;3&#39;</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">5</span> <span class="c1">// &quot;345&quot;</span>
<span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="s1">&#39;5&#39;</span> <span class="c1">// &quot;75&quot;</span>
</pre></div>
</div>
<p>上面代码中，由于从左到右的运算次序，字符串的位置不同会导致不同的结果。</p>
<p>除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="o">-</span> <span class="s1">&#39;2&#39;</span> <span class="c1">// -1</span>
<span class="mi">1</span> <span class="o">*</span> <span class="s1">&#39;2&#39;</span> <span class="c1">// 2</span>
<span class="mi">1</span> <span class="o">/</span> <span class="s1">&#39;2&#39;</span> <span class="c1">// 0.5</span>
</pre></div>
</div>
<p>上面代码中，减法、除法和乘法运算符，都是将字符串自动转为数值，然后再运算。</p>
</div>
<div class="section" id="">
<span id="id4"></span><h3>对象的相加<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>如果运算子是对象，必须先转成原始类型的值，然后再相加。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">p</span><span class="o">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="nx">obj</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1">// &quot;[object Object]2&quot;</span>
</pre></div>
</div>
<p>上面代码中，对象<code class="docutils literal notranslate"><span class="pre">obj</span></code>转成原始类型的值是<code class="docutils literal notranslate"><span class="pre">[object</span> <span class="pre">Object]</span></code>，再加<code class="docutils literal notranslate"><span class="pre">2</span></code>就得到了上面的结果。</p>
<p>对象转成原始类型的值，规则如下。</p>
<p>首先，自动调用对象的<code class="docutils literal notranslate"><span class="pre">valueOf</span></code>方法。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">p</span><span class="o">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">valueOf</span><span class="p">()</span> <span class="c1">// { p: 1 }</span>
</pre></div>
</div>
<p>一般来说，对象的<code class="docutils literal notranslate"><span class="pre">valueOf</span></code>方法总是返回对象自身，这时再自动调用对象的<code class="docutils literal notranslate"><span class="pre">toString</span></code>方法，将其转为字符串。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">p</span><span class="o">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">valueOf</span><span class="p">().</span><span class="nx">toString</span><span class="p">()</span> <span class="c1">// &quot;[object Object]&quot;</span>
</pre></div>
</div>
<p>对象的<code class="docutils literal notranslate"><span class="pre">toString</span></code>方法默认返回<code class="docutils literal notranslate"><span class="pre">[object</span> <span class="pre">Object]</span></code>，所以就得到了最前面那个例子的结果。</p>
<p>知道了这个规则以后，就可以自己定义<code class="docutils literal notranslate"><span class="pre">valueOf</span></code>方法或<code class="docutils literal notranslate"><span class="pre">toString</span></code>方法，得到想要的结果。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">valueOf</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">obj</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1">// 3</span>
</pre></div>
</div>
<p>上面代码中，我们定义<code class="docutils literal notranslate"><span class="pre">obj</span></code>对象的<code class="docutils literal notranslate"><span class="pre">valueOf</span></code>方法返回<code class="docutils literal notranslate"><span class="pre">1</span></code>，于是<code class="docutils literal notranslate"><span class="pre">obj</span> <span class="pre">+</span> <span class="pre">2</span></code>就得到了<code class="docutils literal notranslate"><span class="pre">3</span></code>。这个例子中，由于<code class="docutils literal notranslate"><span class="pre">valueOf</span></code>方法直接返回一个原始类型的值，所以不再调用<code class="docutils literal notranslate"><span class="pre">toString</span></code>方法。</p>
<p>下面是自定义<code class="docutils literal notranslate"><span class="pre">toString</span></code>方法的例子。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">toString</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">obj</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1">// &quot;hello2&quot;</span>
</pre></div>
</div>
<p>上面代码中，对象<code class="docutils literal notranslate"><span class="pre">obj</span></code>的<code class="docutils literal notranslate"><span class="pre">toString</span></code>方法返回字符串<code class="docutils literal notranslate"><span class="pre">hello</span></code>。前面说过，只要有一个运算子是字符串，加法运算符就变成连接运算符，返回连接后的字符串。</p>
<p>这里有一个特例，如果运算子是一个<code class="docutils literal notranslate"><span class="pre">Date</span></code>对象的实例，那么会优先执行<code class="docutils literal notranslate"><span class="pre">toString</span></code>方法。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">valueOf</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span> <span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">toString</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s1">&#39;hello&#39;</span> <span class="p">};</span>

<span class="nx">obj</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1">// &quot;hello2&quot;</span>
</pre></div>
</div>
<p>上面代码中，对象<code class="docutils literal notranslate"><span class="pre">obj</span></code>是一个<code class="docutils literal notranslate"><span class="pre">Date</span></code>对象的实例，并且自定义了<code class="docutils literal notranslate"><span class="pre">valueOf</span></code>方法和<code class="docutils literal notranslate"><span class="pre">toString</span></code>方法，结果<code class="docutils literal notranslate"><span class="pre">toString</span></code>方法优先执行。</p>
</div>
</div>
<div class="section" id="">
<span id="id5"></span><h2>算术运算符<a class="headerlink" href="#" title="永久链接至标题">¶</a></h2>
<p>包括加法运算符在内，JavaScript 共提供10个算术运算符，用来完成基本的算术运算。</p>
<ul class="simple">
<li><strong>加法运算符</strong>：<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code></li>
<li><strong>减法运算符</strong>： <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span></code></li>
<li><strong>乘法运算符</strong>： <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span></code></li>
<li><strong>除法运算符</strong>：<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code></li>
<li><strong>指数运算符</strong>：<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">**</span> <span class="pre">y</span></code></li>
<li><strong>余数运算符</strong>：<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code></li>
<li><strong>自增运算符</strong>：<code class="docutils literal notranslate"><span class="pre">++x</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">x++</span></code></li>
<li><strong>自减运算符</strong>：<code class="docutils literal notranslate"><span class="pre">--x</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">x--</span></code></li>
<li><strong>数值运算符</strong>： <code class="docutils literal notranslate"><span class="pre">+x</span></code></li>
<li><strong>负数值运算符</strong>：<code class="docutils literal notranslate"><span class="pre">-x</span></code></li>
</ul>
<p>减法、乘法、除法运算法比较单纯，就是执行相应的数学运算。下面介绍其他几个算术运算符。</p>
<div class="section" id="">
<span id="id6"></span><h3>余数运算符<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>余数运算符（<code class="docutils literal notranslate"><span class="pre">%</span></code>）返回前一个运算子被后一个运算子除，所得的余数。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mi">12</span> <span class="o">%</span> <span class="mi">5</span> <span class="c1">// 2</span>
</pre></div>
</div>
<p>需要注意的是，运算结果的正负号由第一个运算子的正负号决定。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="o">-</span><span class="mi">1</span> <span class="o">%</span> <span class="mi">2</span> <span class="c1">// -1</span>
<span class="mi">1</span> <span class="o">%</span> <span class="o">-</span><span class="mi">2</span> <span class="c1">// 1</span>
</pre></div>
</div>
<p>所以，为了得到负数的正确余数值，可以先使用绝对值函数。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 错误的写法</span>
<span class="kd">function</span> <span class="nx">isOdd</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">isOdd</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nx">isOdd</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span> <span class="c1">// false</span>

<span class="c1">// 正确的写法</span>
<span class="kd">function</span> <span class="nx">isOdd</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">===</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">isOdd</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nx">isOdd</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span> <span class="c1">// false</span>
</pre></div>
</div>
<p>余数运算符还可以用于浮点数的运算。但是，由于浮点数不是精确的值，无法得到完全准确的结果。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mf">6.5</span> <span class="o">%</span> <span class="mf">2.1</span>
<span class="c1">// 0.19999999999999973</span>
</pre></div>
</div>
</div>
<div class="section" id="">
<span id="id7"></span><h3>自增和自减运算符<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>自增和自减运算符，是一元运算符，只需要一个运算子。它们的作用是将运算子首先转为数值，然后加上1或者减去1。它们会修改原始变量。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">++</span><span class="nx">x</span> <span class="c1">// 2</span>
<span class="nx">x</span> <span class="c1">// 2</span>

<span class="o">--</span><span class="nx">x</span> <span class="c1">// 1</span>
<span class="nx">x</span> <span class="c1">// 1</span>
</pre></div>
</div>
<p>上面代码的变量<code class="docutils literal notranslate"><span class="pre">x</span></code>自增后，返回<code class="docutils literal notranslate"><span class="pre">2</span></code>，再进行自减，返回<code class="docutils literal notranslate"><span class="pre">1</span></code>。这两种情况都会使得，原始变量<code class="docutils literal notranslate"><span class="pre">x</span></code>的值发生改变。</p>
<p>自增和自减运算符有一个需要注意的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nx">x</span><span class="o">++</span> <span class="c1">// 1</span>
<span class="o">++</span><span class="nx">y</span> <span class="c1">// 2</span>
</pre></div>
</div>
<p>上面代码中，<code class="docutils literal notranslate"><span class="pre">x</span></code>是先返回当前值，然后自增，所以得到<code class="docutils literal notranslate"><span class="pre">1</span></code>；<code class="docutils literal notranslate"><span class="pre">y</span></code>是先自增，然后返回新的值，所以得到<code class="docutils literal notranslate"><span class="pre">2</span></code>。</p>
</div>
<div class="section" id="">
<span id="id8"></span><h3>数值运算符，负数值运算符<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>数值运算符（<code class="docutils literal notranslate"><span class="pre">+</span></code>）同样使用加号，但它是一元运算符（只需要一个操作数），而加法运算符是二元运算符（需要两个操作数）。</p>
<p>数值运算符的作用在于可以将任何值转为数值（与<code class="docutils literal notranslate"><span class="pre">Number</span></code>函数的作用相同）。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="o">+</span><span class="kc">true</span> <span class="c1">// 1</span>
<span class="o">+</span><span class="p">[]</span> <span class="c1">// 0</span>
<span class="o">+</span><span class="p">{}</span> <span class="c1">// NaN</span>
</pre></div>
</div>
<p>上面代码表示，非数值经过数值运算符以后，都变成了数值（最后一行<code class="docutils literal notranslate"><span class="pre">NaN</span></code>也是数值）。具体的类型转换规则，参见《数据类型转换》一章。</p>
<p>负数值运算符（<code class="docutils literal notranslate"><span class="pre">-</span></code>），也同样具有将一个值转为数值的功能，只不过得到的值正负相反。连用两个负数值运算符，等同于数值运算符。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">-</span><span class="nx">x</span> <span class="c1">// -1</span>
<span class="o">-</span><span class="p">(</span><span class="o">-</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// 1</span>
</pre></div>
</div>
<p>上面代码最后一行的圆括号不可少，否则会变成自减运算符。</p>
<p>数值运算符号和负数值运算符，都会返回一个新的值，而不会改变原始变量的值。</p>
</div>
<div class="section" id="">
<span id="id9"></span><h3>指数运算符<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>指数运算符（<code class="docutils literal notranslate"><span class="pre">**</span></code>）完成指数运算，前一个运算子是底数，后一个运算子是指数。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mi">2</span> <span class="o">**</span> <span class="mi">4</span> <span class="c1">// 16</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="">
<span id="id10"></span><h2>赋值运算符<a class="headerlink" href="#" title="永久链接至标题">¶</a></h2>
<p>赋值运算符（Assignment Operators）用于给变量赋值。</p>
<p>最常见的赋值运算符，当然就是等号（<code class="docutils literal notranslate"><span class="pre">=</span></code>）。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 将 1 赋值给变量 x</span>
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// 将变量 y 的值赋值给变量 x</span>
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
</pre></div>
</div>
<p>赋值运算符还可以与其他运算符结合，形成变体。下面是与算术运算符的结合。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 等同于 x = x + y</span>
<span class="nx">x</span> <span class="o">+=</span> <span class="nx">y</span>

<span class="c1">// 等同于 x = x - y</span>
<span class="nx">x</span> <span class="o">-=</span> <span class="nx">y</span>

<span class="c1">// 等同于 x = x * y</span>
<span class="nx">x</span> <span class="o">*=</span> <span class="nx">y</span>

<span class="c1">// 等同于 x = x / y</span>
<span class="nx">x</span> <span class="o">/=</span> <span class="nx">y</span>

<span class="c1">// 等同于 x = x % y</span>
<span class="nx">x</span> <span class="o">%=</span> <span class="nx">y</span>

<span class="c1">// 等同于 x = x ** y</span>
<span class="nx">x</span> <span class="o">**=</span> <span class="nx">y</span>
</pre></div>
</div>
<p>下面是与位运算符的结合（关于位运算符，请见后文的介绍）。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 等同于 x = x &gt;&gt; y</span>
<span class="nx">x</span> <span class="o">&gt;&gt;=</span> <span class="nx">y</span>

<span class="c1">// 等同于 x = x &lt;&lt; y</span>
<span class="nx">x</span> <span class="o">&lt;&lt;=</span> <span class="nx">y</span>

<span class="c1">// 等同于 x = x &gt;&gt;&gt; y</span>
<span class="nx">x</span> <span class="o">&gt;&gt;&gt;=</span> <span class="nx">y</span>

<span class="c1">// 等同于 x = x &amp; y</span>
<span class="nx">x</span> <span class="o">&amp;=</span> <span class="nx">y</span>

<span class="c1">// 等同于 x = x | y</span>
<span class="nx">x</span> <span class="o">|=</span> <span class="nx">y</span>

<span class="c1">// 等同于 x = x ^ y</span>
<span class="nx">x</span> <span class="o">^=</span> <span class="nx">y</span>
</pre></div>
</div>
<p>这些复合的赋值运算符，都是先进行指定运算，然后将得到值返回给左边的变量。</p>
</div>
<div class="section" id="">
<span id="id11"></span><h2>比较运算符<a class="headerlink" href="#" title="永久链接至标题">¶</a></h2>
<p>比较运算符用于比较两个值的大小，然后返回一个布尔值，表示是否满足指定的条件。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="c1">// true</span>
</pre></div>
</div>
<p>上面代码比较<code class="docutils literal notranslate"><span class="pre">2</span></code>是否大于<code class="docutils literal notranslate"><span class="pre">1</span></code>，返回<code class="docutils literal notranslate"><span class="pre">true</span></code>。</p>
<p>注意，比较运算符可以比较各种类型的值，不仅仅是数值。</p>
<p>JavaScript 一共提供了8个比较运算符。</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">&lt;</span></code> 小于运算符</li>
<li><code class="docutils literal notranslate"><span class="pre">&gt;</span></code> 大于运算符</li>
<li><code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> 小于或等于运算符</li>
<li><code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 大于或等于运算符</li>
<li><code class="docutils literal notranslate"><span class="pre">==</span></code> 相等运算符</li>
<li><code class="docutils literal notranslate"><span class="pre">===</span></code> 严格相等运算符</li>
<li><code class="docutils literal notranslate"><span class="pre">!=</span></code> 不相等运算符</li>
<li><code class="docutils literal notranslate"><span class="pre">!==</span></code> 严格不相等运算符</li>
</ul>
<p>这八个比较运算符分成两类：相等比较和非相等比较。两者的规则是不一样的，对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小。</p>
<div class="section" id="">
<span id="id12"></span><h3>字符串的比较<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>字符串按照字典顺序进行比较。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;cat&#39;</span> <span class="o">&gt;</span> <span class="s1">&#39;dog&#39;</span> <span class="c1">// false</span>
<span class="s1">&#39;cat&#39;</span> <span class="o">&gt;</span> <span class="s1">&#39;catalog&#39;</span> <span class="c1">// false</span>
</pre></div>
</div>
<p>JavaScript 引擎内部首先比较首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;cat&#39;</span> <span class="o">&gt;</span> <span class="s1">&#39;Cat&#39;</span> <span class="c1">// true&#39;</span>
</pre></div>
</div>
<p>上面代码中，小写的<code class="docutils literal notranslate"><span class="pre">c</span></code>的 Unicode 码点（<code class="docutils literal notranslate"><span class="pre">99</span></code>）大于大写的<code class="docutils literal notranslate"><span class="pre">C</span></code>的 Unicode 码点（<code class="docutils literal notranslate"><span class="pre">67</span></code>），所以返回<code class="docutils literal notranslate"><span class="pre">true</span></code>。</p>
<p>由于所有字符都有 Unicode 码点，因此汉字也可以比较。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;大&#39;</span> <span class="o">&gt;</span> <span class="s1">&#39;小&#39;</span> <span class="c1">// false</span>
</pre></div>
</div>
<p>上面代码中，“大”的 Unicode 码点是22823，“小”是23567，因此返回<code class="docutils literal notranslate"><span class="pre">false</span></code>。</p>
</div>
<div class="section" id="">
<span id="id13"></span><h3>非字符串的比较<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p><strong>（1）原始类型的值</strong></p>
<p>两个原始类型的值的比较，除了相等运算符（<code class="docutils literal notranslate"><span class="pre">==</span></code>）和严格相等运算符（<code class="docutils literal notranslate"><span class="pre">===</span></code>），其他比较运算符都是先转成数值再比较。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mi">5</span> <span class="o">&gt;</span> <span class="s1">&#39;4&#39;</span> <span class="c1">// true</span>
<span class="c1">// 等同于 5 &gt; Number(&#39;4&#39;)</span>
<span class="c1">// 即 5 &gt; 4</span>

<span class="kc">true</span> <span class="o">&gt;</span> <span class="kc">false</span> <span class="c1">// true</span>
<span class="c1">// 等同于 Number(true) &gt; Number(false)</span>
<span class="c1">// 即 1 &gt; 0</span>

<span class="mi">2</span> <span class="o">&gt;</span> <span class="kc">true</span> <span class="c1">// true</span>
<span class="c1">// 等同于 2 &gt; Number(true)</span>
<span class="c1">// 即 2 &gt; 1</span>
</pre></div>
</div>
<p>上面代码中，字符串和布尔值都会先转成数值，再进行比较。</p>
<p>这里有一个特殊情况，即任何值（包括<code class="docutils literal notranslate"><span class="pre">NaN</span></code>本身）与<code class="docutils literal notranslate"><span class="pre">NaN</span></code>比较，返回的都是<code class="docutils literal notranslate"><span class="pre">false</span></code>。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="o">&gt;</span> <span class="kc">NaN</span> <span class="c1">// false</span>
<span class="mi">1</span> <span class="o">&lt;=</span> <span class="kc">NaN</span> <span class="c1">// false</span>
<span class="s1">&#39;1&#39;</span> <span class="o">&gt;</span> <span class="kc">NaN</span> <span class="c1">// false</span>
<span class="s1">&#39;1&#39;</span> <span class="o">&lt;=</span> <span class="kc">NaN</span> <span class="c1">// false</span>
<span class="kc">NaN</span> <span class="o">&gt;</span> <span class="kc">NaN</span> <span class="c1">// false</span>
<span class="kc">NaN</span> <span class="o">&lt;=</span> <span class="kc">NaN</span> <span class="c1">// false</span>
</pre></div>
</div>
<p><strong>（2）对象</strong></p>
<p>如果运算子是对象，会转为原始类型的值，再进行比较。</p>
<p>对象转换成原始类型的值，算法是先调用<code class="docutils literal notranslate"><span class="pre">valueOf</span></code>方法；如果返回的还是对象，再接着调用<code class="docutils literal notranslate"><span class="pre">toString</span></code>方法，详细解释参见《数据类型的转换》一章。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="nx">x</span> <span class="o">&gt;</span> <span class="s1">&#39;11&#39;</span> <span class="c1">// true</span>
<span class="c1">// 等同于 [2].valueOf().toString() &gt; &#39;11&#39;</span>
<span class="c1">// 即 &#39;2&#39; &gt; &#39;11&#39;</span>

<span class="nx">x</span><span class="p">.</span><span class="nx">valueOf</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s1">&#39;1&#39;</span> <span class="p">};</span>
<span class="nx">x</span> <span class="o">&gt;</span> <span class="s1">&#39;11&#39;</span> <span class="c1">// false</span>
<span class="c1">// 等同于 [2].valueOf() &gt; &#39;11&#39;</span>
<span class="c1">// 即 &#39;1&#39; &gt; &#39;11&#39;</span>
</pre></div>
</div>
<p>两个对象之间的比较也是如此。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// true</span>
<span class="c1">// 等同于 [2].valueOf().toString() &gt; [1].valueOf().toString()</span>
<span class="c1">// 即 &#39;2&#39; &gt; &#39;1&#39;</span>

<span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="c1">// true</span>
<span class="c1">// 等同于 [2].valueOf().toString() &gt; [11].valueOf().toString()</span>
<span class="c1">// 即 &#39;2&#39; &gt; &#39;11&#39;</span>

<span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="mi">2</span><span class="p">}</span> <span class="o">&gt;=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">}</span> <span class="c1">// true</span>
<span class="c1">// 等同于 {x: 2}.valueOf().toString() &gt;= {x: 1}.valueOf().toString()</span>
<span class="c1">// 即 &#39;[object Object]&#39; &gt;= &#39;[object Object]&#39;</span>
</pre></div>
</div>
<p>注意，Date 对象实例用于比较时，是先调用<code class="docutils literal notranslate"><span class="pre">toString</span></code>方法。如果返回的不是原始类型的值，再接着对返回值调用<code class="docutils literal notranslate"><span class="pre">valueOf</span></code>方法。</p>
</div>
<div class="section" id="">
<span id="id14"></span><h3>严格相等运算符<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>JavaScript 提供两种相等运算符：<code class="docutils literal notranslate"><span class="pre">==</span></code>和<code class="docutils literal notranslate"><span class="pre">===</span></code>。</p>
<p>简单说，它们的区别是相等运算符（<code class="docutils literal notranslate"><span class="pre">==</span></code>）比较两个值是否相等，严格相等运算符（<code class="docutils literal notranslate"><span class="pre">===</span></code>）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（<code class="docutils literal notranslate"><span class="pre">===</span></code>）直接返回<code class="docutils literal notranslate"><span class="pre">false</span></code>，而相等运算符（<code class="docutils literal notranslate"><span class="pre">==</span></code>）会将它们转换成同一个类型，再用严格相等运算符进行比较。</p>
<p>严格相等运算符的算法如下。</p>
<p><strong>（1）不同类型的值</strong></p>
<p>如果两个值的类型不同，直接返回<code class="docutils literal notranslate"><span class="pre">false</span></code>。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="o">===</span> <span class="s2">&quot;1&quot;</span> <span class="c1">// false</span>
<span class="kc">true</span> <span class="o">===</span> <span class="s2">&quot;true&quot;</span> <span class="c1">// false</span>
</pre></div>
</div>
<p>上面代码比较数值的<code class="docutils literal notranslate"><span class="pre">1</span></code>与字符串的“1”、布尔值的<code class="docutils literal notranslate"><span class="pre">true</span></code>与字符串<code class="docutils literal notranslate"><span class="pre">&quot;true&quot;</span></code>，因为类型不同，结果都是<code class="docutils literal notranslate"><span class="pre">false</span></code>。</p>
<p><strong>（2）同一类的原始类型值</strong></p>
<p>同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回<code class="docutils literal notranslate"><span class="pre">true</span></code>，值不同就返回<code class="docutils literal notranslate"><span class="pre">false</span></code>。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="o">===</span> <span class="mh">0x1</span> <span class="c1">// true</span>
</pre></div>
</div>
<p>上面代码比较十进制的<code class="docutils literal notranslate"><span class="pre">1</span></code>与十六进制的<code class="docutils literal notranslate"><span class="pre">1</span></code>，因为类型和值都相同，返回<code class="docutils literal notranslate"><span class="pre">true</span></code>。</p>
<p>需要注意的是，<code class="docutils literal notranslate"><span class="pre">NaN</span></code>与任何值都不相等（包括自身）。另外，正<code class="docutils literal notranslate"><span class="pre">0</span></code>等于负<code class="docutils literal notranslate"><span class="pre">0</span></code>。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kc">NaN</span> <span class="o">===</span> <span class="kc">NaN</span>  <span class="c1">// false</span>
<span class="o">+</span><span class="mi">0</span> <span class="o">===</span> <span class="o">-</span><span class="mi">0</span> <span class="c1">// true</span>
</pre></div>
</div>
<p><strong>（3）复合类型值</strong></p>
<p>两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="p">{}</span> <span class="o">===</span> <span class="p">{}</span> <span class="c1">// false</span>
<span class="p">[]</span> <span class="o">===</span> <span class="p">[]</span> <span class="c1">// false</span>
<span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{}</span> <span class="o">===</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{})</span> <span class="c1">// false</span>
</pre></div>
</div>
<p>上面代码分别比较两个空对象、两个空数组、两个空函数，结果都是不相等。原因是对于复合类型的值，严格相等运算比较的是，它们是否引用同一个内存地址，而运算符两边的空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是<code class="docutils literal notranslate"><span class="pre">false</span></code>。</p>
<p>如果两个变量引用同一个对象，则它们相等。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">v1</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kd">var</span> <span class="nx">v2</span> <span class="o">=</span> <span class="nx">v1</span><span class="p">;</span>
<span class="nx">v1</span> <span class="o">===</span> <span class="nx">v2</span> <span class="c1">// true</span>
</pre></div>
</div>
<p>注意，对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="nb">Date</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">()</span> <span class="c1">// false</span>
<span class="k">new</span> <span class="nb">Date</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">()</span> <span class="c1">// false</span>
<span class="k">new</span> <span class="nb">Date</span><span class="p">()</span> <span class="o">===</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">()</span> <span class="c1">// false</span>
</pre></div>
</div>
<p>上面的三个表达式，前两个比较的是值，最后一个比较的是地址，所以都返回<code class="docutils literal notranslate"><span class="pre">false</span></code>。</p>
<p><strong>（4）undefined 和 null</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">undefined</span></code>和<code class="docutils literal notranslate"><span class="pre">null</span></code>与自身严格相等。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kc">undefined</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="c1">// true</span>
<span class="kc">null</span> <span class="o">===</span> <span class="kc">null</span> <span class="c1">// true</span>
</pre></div>
</div>
<p>由于变量声明后默认值是<code class="docutils literal notranslate"><span class="pre">undefined</span></code>，因此两个只声明未赋值的变量是相等的。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">v1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">v2</span><span class="p">;</span>
<span class="nx">v1</span> <span class="o">===</span> <span class="nx">v2</span> <span class="c1">// true</span>
</pre></div>
</div>
<p><strong>（5）严格不相等运算符</strong></p>
<p>严格相等运算符有一个对应的“严格不相等运算符”（<code class="docutils literal notranslate"><span class="pre">!==</span></code>），它的算法就是先求严格相等运算符的结果，然后返回相反值。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="o">!==</span> <span class="s1">&#39;1&#39;</span> <span class="c1">// true</span>
</pre></div>
</div>
</div>
<div class="section" id="">
<span id="id15"></span><h3>相等运算符<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。</p>
<p>比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。类型转换规则如下。</p>
<p><strong>（1）原始类型的值</strong></p>
<p>原始类型的数据会转换成数值类型再进行比较。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="o">==</span> <span class="kc">true</span> <span class="c1">// true</span>
<span class="c1">// 等同于 1 === Number(true)</span>

<span class="mi">0</span> <span class="o">==</span> <span class="kc">false</span> <span class="c1">// true</span>
<span class="c1">// 等同于 0 === Number(false)</span>

<span class="mi">2</span> <span class="o">==</span> <span class="kc">true</span> <span class="c1">// false</span>
<span class="c1">// 等同于 2 === Number(true)</span>

<span class="mi">2</span> <span class="o">==</span> <span class="kc">false</span> <span class="c1">// false</span>
<span class="c1">// 等同于 2 === Number(false)</span>

<span class="s1">&#39;true&#39;</span> <span class="o">==</span> <span class="kc">true</span> <span class="c1">// false</span>
<span class="c1">// 等同于 Number(&#39;true&#39;) === Number(true)</span>
<span class="c1">// 等同于 NaN === 1</span>

<span class="s1">&#39;&#39;</span> <span class="o">==</span> <span class="mi">0</span> <span class="c1">// true</span>
<span class="c1">// 等同于 Number(&#39;&#39;) === 0</span>
<span class="c1">// 等同于 0 === 0</span>

<span class="s1">&#39;&#39;</span> <span class="o">==</span> <span class="kc">false</span>  <span class="c1">// true</span>
<span class="c1">// 等同于 Number(&#39;&#39;) === Number(false)</span>
<span class="c1">// 等同于 0 === 0</span>

<span class="s1">&#39;1&#39;</span> <span class="o">==</span> <span class="kc">true</span>  <span class="c1">// true</span>
<span class="c1">// 等同于 Number(&#39;1&#39;) === Number(true)</span>
<span class="c1">// 等同于 1 === 1</span>

<span class="s1">&#39;\n  123  \t&#39;</span> <span class="o">==</span> <span class="mi">123</span> <span class="c1">// true</span>
<span class="c1">// 因为字符串转为数字时，省略前置和后置的空格</span>
</pre></div>
</div>
<p>上面代码将字符串和布尔值都转为数值，然后再进行比较。具体的字符串与布尔值的类型转换规则，参见《数据类型转换》一章。</p>
<p><strong>（2）对象与原始类型值比较</strong></p>
<p>对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="c1">// true</span>
<span class="c1">// 等同于 Number([1]) == 1</span>

<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span> <span class="c1">// true</span>
<span class="c1">// 等同于 Number([1]) == Number(&#39;1&#39;)</span>

<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="kc">true</span> <span class="c1">// true</span>
<span class="c1">// 等同于 Number([1]) == Number(true)</span>
</pre></div>
</div>
<p>上面代码中，数组<code class="docutils literal notranslate"><span class="pre">[1]</span></code>与数值进行比较，会先转成数值，再进行比较；与字符串进行比较，会先转成数值，然后再与字符串进行比较，这时字符串也会转成数值；与布尔值进行比较，两个运算子都会先转成数值，然后再进行比较。</p>
<p><strong>（3）undefined 和 null</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">undefined</span></code>和<code class="docutils literal notranslate"><span class="pre">null</span></code>与其他类型的值比较时，结果都为<code class="docutils literal notranslate"><span class="pre">false</span></code>，它们互相比较时结果为<code class="docutils literal notranslate"><span class="pre">true</span></code>。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kc">false</span> <span class="o">==</span> <span class="kc">null</span> <span class="c1">// false</span>
<span class="kc">false</span> <span class="o">==</span> <span class="kc">undefined</span> <span class="c1">// false</span>

<span class="mi">0</span> <span class="o">==</span> <span class="kc">null</span> <span class="c1">// false</span>
<span class="mi">0</span> <span class="o">==</span> <span class="kc">undefined</span> <span class="c1">// false</span>

<span class="kc">undefined</span> <span class="o">==</span> <span class="kc">null</span> <span class="c1">// true</span>
</pre></div>
</div>
<p>绝大多数情况下，对象与<code class="docutils literal notranslate"><span class="pre">undefined</span></code>和<code class="docutils literal notranslate"><span class="pre">null</span></code>比较，都返回<code class="docutils literal notranslate"><span class="pre">false</span></code>。只有在对象转为原始值得到<code class="docutils literal notranslate"><span class="pre">undefined</span></code>时，才会返回<code class="docutils literal notranslate"><span class="pre">true</span></code>，这种情况是非常罕见的。</p>
<p><strong>（4）相等运算符的缺点</strong></p>
<p>相等运算符隐藏的类型转换，会带来一些违反直觉的结果。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span>             <span class="c1">// true</span>
<span class="mi">0</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span>            <span class="c1">// true</span>

<span class="mi">2</span> <span class="o">==</span> <span class="kc">true</span>           <span class="c1">// false</span>
<span class="mi">2</span> <span class="o">==</span> <span class="kc">false</span>          <span class="c1">// false</span>

<span class="kc">false</span> <span class="o">==</span> <span class="s1">&#39;false&#39;</span>    <span class="c1">// false</span>
<span class="kc">false</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span>        <span class="c1">// true</span>

<span class="kc">false</span> <span class="o">==</span> <span class="kc">undefined</span>  <span class="c1">// false</span>
<span class="kc">false</span> <span class="o">==</span> <span class="kc">null</span>       <span class="c1">// false</span>
<span class="kc">null</span> <span class="o">==</span> <span class="kc">undefined</span>   <span class="c1">// true</span>

<span class="s1">&#39; \t\r\n &#39;</span> <span class="o">==</span> <span class="mi">0</span>     <span class="c1">// true</span>
</pre></div>
</div>
<p>上面这些表达式都很容易出错，因此不要使用相等运算符（<code class="docutils literal notranslate"><span class="pre">==</span></code>），最好只使用严格相等运算符（<code class="docutils literal notranslate"><span class="pre">===</span></code>）。</p>
<p><strong>（5）不相等运算符</strong></p>
<p>相等运算符有一个对应的“不相等运算符”（<code class="docutils literal notranslate"><span class="pre">!=</span></code>），两者的运算结果正好相反。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="o">!=</span> <span class="s1">&#39;1&#39;</span> <span class="c1">// false</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="">
<span id="id16"></span><h2>布尔运算符<a class="headerlink" href="#" title="永久链接至标题">¶</a></h2>
<p>布尔运算符用于将表达式转为布尔值，一共包含四个运算符。</p>
<ul class="simple">
<li>取反运算符：<code class="docutils literal notranslate"><span class="pre">!</span></code></li>
<li>且运算符：<code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code></li>
<li>或运算符：<code class="docutils literal notranslate"><span class="pre">||</span></code></li>
<li>三元运算符：<code class="docutils literal notranslate"><span class="pre">?:</span></code></li>
</ul>
<div class="section" id="">
<span id="id17"></span><h3>取反运算符（!）<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>取反运算符是一个感叹号，用于将布尔值变为相反值，即<code class="docutils literal notranslate"><span class="pre">true</span></code>变成<code class="docutils literal notranslate"><span class="pre">false</span></code>，<code class="docutils literal notranslate"><span class="pre">false</span></code>变成<code class="docutils literal notranslate"><span class="pre">true</span></code>。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="o">!</span><span class="kc">true</span> <span class="c1">// false</span>
<span class="o">!</span><span class="kc">false</span> <span class="c1">// true</span>
</pre></div>
</div>
<p>对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为<code class="docutils literal notranslate"><span class="pre">true</span></code>，其他值都为<code class="docutils literal notranslate"><span class="pre">false</span></code>。</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">undefined</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">null</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">false</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">0</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">NaN</span></code></li>
<li>空字符串（<code class="docutils literal notranslate"><span class="pre">''</span></code>）</li>
</ul>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="o">!</span><span class="kc">undefined</span> <span class="c1">// true</span>
<span class="o">!</span><span class="kc">null</span> <span class="c1">// true</span>
<span class="o">!</span><span class="mi">0</span> <span class="c1">// true</span>
<span class="o">!</span><span class="kc">NaN</span> <span class="c1">// true</span>
<span class="o">!</span><span class="s2">&quot;&quot;</span> <span class="c1">// true</span>

<span class="o">!</span><span class="mi">54</span> <span class="c1">// false</span>
<span class="o">!</span><span class="s1">&#39;hello&#39;</span> <span class="c1">// false</span>
<span class="o">!</span><span class="p">[]</span> <span class="c1">// false</span>
<span class="o">!</span><span class="p">{}</span> <span class="c1">// false</span>
</pre></div>
</div>
<p>上面代码中，不管什么类型的值，经过取反运算后，都变成了布尔值。</p>
<p>如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，与<code class="docutils literal notranslate"><span class="pre">Boolean</span></code>函数的作用相同。这是一种常用的类型转换的写法。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="o">!!</span><span class="nx">x</span>
<span class="c1">// 等同于</span>
<span class="nb">Boolean</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</pre></div>
</div>
<p>上面代码中，不管<code class="docutils literal notranslate"><span class="pre">x</span></code>是什么类型的值，经过两次取反运算后，变成了与<code class="docutils literal notranslate"><span class="pre">Boolean</span></code>函数结果相同的布尔值。所以，两次取反就是将一个值转为布尔值的简便写法。</p>
</div>
<div class="section" id="">
<span id="id18"></span><h3>且运算符（&amp;&amp;）<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>且运算符（<code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>）往往用于多个表达式的求值。</p>
<p>它的运算规则是：如果第一个运算子的布尔值为<code class="docutils literal notranslate"><span class="pre">true</span></code>，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为<code class="docutils literal notranslate"><span class="pre">false</span></code>，则直接返回第一个运算子的值，且不再对第二个运算子求值。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;t&#39;</span> <span class="o">&amp;&amp;</span> <span class="s1">&#39;&#39;</span> <span class="c1">// &quot;&quot;</span>
<span class="s1">&#39;t&#39;</span> <span class="o">&amp;&amp;</span> <span class="s1">&#39;f&#39;</span> <span class="c1">// &quot;f&quot;</span>
<span class="s1">&#39;t&#39;</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// 3</span>
<span class="s1">&#39;&#39;</span> <span class="o">&amp;&amp;</span> <span class="s1">&#39;f&#39;</span> <span class="c1">// &quot;&quot;</span>
<span class="s1">&#39;&#39;</span> <span class="o">&amp;&amp;</span> <span class="s1">&#39;&#39;</span> <span class="c1">// &quot;&quot;</span>

<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 0</span>
<span class="nx">x</span> <span class="c1">// 1</span>
</pre></div>
</div>
<p>上面代码的最后一个例子，由于且运算符的第一个运算子的布尔值为<code class="docutils literal notranslate"><span class="pre">false</span></code>，则直接返回它的值<code class="docutils literal notranslate"><span class="pre">0</span></code>，而不再对第二个运算子求值，所以变量<code class="docutils literal notranslate"><span class="pre">x</span></code>的值没变。</p>
<p>这种跳过第二个运算子的机制，被称为“短路”。有些程序员喜欢用它取代<code class="docutils literal notranslate"><span class="pre">if</span></code>结构，比如下面是一段<code class="docutils literal notranslate"><span class="pre">if</span></code>结构的代码，就可以用且运算符改写。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">doSomething</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 等价于</span>

<span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nx">doSomething</span><span class="p">();</span>
</pre></div>
</div>
<p>上面代码的两种写法是等价的，但是后一种不容易看出目的，也不容易除错，建议谨慎使用。</p>
<p>且运算符可以多个连用，这时返回第一个布尔值为<code class="docutils literal notranslate"><span class="pre">false</span></code>的表达式的值。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kc">true</span> <span class="o">&amp;&amp;</span> <span class="s1">&#39;foo&#39;</span> <span class="o">&amp;&amp;</span> <span class="s1">&#39;&#39;</span> <span class="o">&amp;&amp;</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="s1">&#39;foo&#39;</span> <span class="o">&amp;&amp;</span> <span class="kc">true</span>
<span class="c1">// &#39;&#39;</span>
</pre></div>
</div>
<p>上面代码中，第一个布尔值为<code class="docutils literal notranslate"><span class="pre">false</span></code>的表达式为第三个表达式，所以得到一个空字符串。</p>
</div>
<div class="section" id="">
<span id="id19"></span><h3>或运算符（||）<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>或运算符（<code class="docutils literal notranslate"><span class="pre">||</span></code>）也用于多个表达式的求值。它的运算规则是：如果第一个运算子的布尔值为<code class="docutils literal notranslate"><span class="pre">true</span></code>，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为<code class="docutils literal notranslate"><span class="pre">false</span></code>，则返回第二个运算子的值。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;t&#39;</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span> <span class="c1">// &quot;t&quot;</span>
<span class="s1">&#39;t&#39;</span> <span class="o">||</span> <span class="s1">&#39;f&#39;</span> <span class="c1">// &quot;t&quot;</span>
<span class="s1">&#39;&#39;</span> <span class="o">||</span> <span class="s1">&#39;f&#39;</span> <span class="c1">// &quot;f&quot;</span>
<span class="s1">&#39;&#39;</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span> <span class="c1">// &quot;&quot;</span>
</pre></div>
</div>
<p>短路规则对这个运算符也适用。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kc">true</span> <span class="o">||</span> <span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nx">x</span> <span class="c1">// 1</span>
</pre></div>
</div>
<p>上面代码中，且运算符的第一个运算子为<code class="docutils literal notranslate"><span class="pre">true</span></code>，所以直接返回<code class="docutils literal notranslate"><span class="pre">true</span></code>，不再运行第二个运算子。所以，<code class="docutils literal notranslate"><span class="pre">x</span></code>的值没有改变。这种只通过第一个表达式的值，控制是否运行第二个表达式的机制，就称为“短路”（short-cut）。</p>
<p>或运算符可以多个连用，这时返回第一个布尔值为<code class="docutils literal notranslate"><span class="pre">true</span></code>的表达式的值。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kc">false</span> <span class="o">||</span> <span class="mi">0</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span> <span class="o">||</span> <span class="mi">4</span> <span class="o">||</span> <span class="s1">&#39;foo&#39;</span> <span class="o">||</span> <span class="kc">true</span>
<span class="c1">// 4</span>
</pre></div>
</div>
<p>上面代码中第一个布尔值为<code class="docutils literal notranslate"><span class="pre">true</span></code>的表达式是第四个表达式，所以得到数值4。</p>
<p>或运算符常用于为一个变量设置默认值。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">saveText</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">text</span> <span class="o">=</span> <span class="nx">text</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// 或者写成</span>
<span class="nx">saveText</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">text</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>上面代码表示，如果函数调用时，没有提供参数，则该参数默认设置为空字符串。</p>
</div>
<div class="section" id="">
<span id="id20"></span><h3>三元条件运算符（?:）<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>三元条件运算符由问号（?）和冒号（:）组成，分隔三个表达式。它是 JavaScript 语言唯一一个需要三个运算子的运算符。如果第一个表达式的布尔值为<code class="docutils literal notranslate"><span class="pre">true</span></code>，则返回第二个表达式的值，否则返回第三个表达式的值。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;t&#39;</span> <span class="o">?</span> <span class="s1">&#39;hello&#39;</span> <span class="o">:</span> <span class="s1">&#39;world&#39;</span> <span class="c1">// &quot;hello&quot;</span>
<span class="mi">0</span> <span class="o">?</span> <span class="s1">&#39;hello&#39;</span> <span class="o">:</span> <span class="s1">&#39;world&#39;</span> <span class="c1">// &quot;world&quot;</span>
</pre></div>
</div>
<p>上面代码的<code class="docutils literal notranslate"><span class="pre">t</span></code>和<code class="docutils literal notranslate"><span class="pre">0</span></code>的布尔值分别为<code class="docutils literal notranslate"><span class="pre">true</span></code>和<code class="docutils literal notranslate"><span class="pre">false</span></code>，所以分别返回第二个和第三个表达式的值。</p>
<p>通常来说，三元条件表达式与<code class="docutils literal notranslate"><span class="pre">if...else</span></code>语句具有同样表达效果，前者可以表达的，后者也能表达。但是两者具有一个重大差别，<code class="docutils literal notranslate"><span class="pre">if...else</span></code>是语句，没有返回值；三元条件表达式是表达式，具有返回值。所以，在需要返回值的场合，只能使用三元条件表达式，而不能使用<code class="docutils literal notranslate"><span class="pre">if..else</span></code>。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kc">true</span> <span class="o">?</span> <span class="s1">&#39;T&#39;</span> <span class="o">:</span> <span class="s1">&#39;F&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>上面代码中，<code class="docutils literal notranslate"><span class="pre">console.log</span></code>方法的参数必须是一个表达式，这时就只能使用三元条件表达式。如果要用<code class="docutils literal notranslate"><span class="pre">if...else</span></code>语句，就必须改变整个代码写法了。</p>
</div>
</div>
<div class="section" id="">
<span id="id21"></span><h2>位运算符<a class="headerlink" href="#" title="永久链接至标题">¶</a></h2>
<div class="section" id="">
<span id="id22"></span><h3>概述<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>位运算符用于直接对二进制位进行计算，一共有7个。</p>
<ul class="simple">
<li><strong>二进制或运算符</strong>（or）：符号为<code class="docutils literal notranslate"><span class="pre">|</span></code>，表示若两个二进制位都为<code class="docutils literal notranslate"><span class="pre">0</span></code>，则结果为<code class="docutils literal notranslate"><span class="pre">0</span></code>，否则为<code class="docutils literal notranslate"><span class="pre">1</span></code>。</li>
<li><strong>二进制与运算符</strong>（and）：符号为<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>，表示若两个二进制位都为1，则结果为1，否则为0。</li>
<li><strong>二进制否运算符</strong>（not）：符号为<code class="docutils literal notranslate"><span class="pre">~</span></code>，表示对一个二进制位取反。</li>
<li><strong>异或运算符</strong>（xor）：符号为<code class="docutils literal notranslate"><span class="pre">^</span></code>，表示若两个二进制位不相同，则结果为1，否则为0。</li>
<li><strong>左移运算符</strong>（left shift）：符号为<code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>，详见下文解释。</li>
<li><strong>右移运算符</strong>（right shift）：符号为<code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>，详见下文解释。</li>
<li><strong>带符号位的右移运算符</strong>（zero filled right shift）：符号为<code class="docutils literal notranslate"><span class="pre">&gt;&gt;&gt;</span></code>，详见下文解释。</li>
</ul>
<p>这些位运算符直接处理每一个比特位（bit），所以是非常底层的运算，好处是速度极快，缺点是很不直观，许多场合不能使用它们，否则会使代码难以理解和查错。</p>
<p>有一点需要特别注意，位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">i</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">|</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>上面这行代码的意思，就是将<code class="docutils literal notranslate"><span class="pre">i</span></code>（不管是整数或小数）转为32位整数。</p>
<p>利用这个特性，可以写出一个函数，将任意数值转为32位整数。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">toInt32</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">|</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面这个函数将任意值与<code class="docutils literal notranslate"><span class="pre">0</span></code>进行一次或运算，这个位运算会自动将一个值转为32位整数。下面是这个函数的用法。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">toInt32</span><span class="p">(</span><span class="mf">1.001</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nx">toInt32</span><span class="p">(</span><span class="mf">1.999</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nx">toInt32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nx">toInt32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// -1</span>
<span class="nx">toInt32</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nx">toInt32</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// -1</span>
</pre></div>
</div>
<p>上面代码中，<code class="docutils literal notranslate"><span class="pre">toInt32</span></code>可以将小数转为整数。对于一般的整数，返回值不会有任何变化。对于大于2的32次方的整数，大于32位的数位都会被舍去。</p>
</div>
<div class="section" id="">
<span id="id23"></span><h3>二进制或运算符<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>二进制或运算符（<code class="docutils literal notranslate"><span class="pre">|</span></code>）逐位比较两个运算子，两个二进制位之中只要有一个为<code class="docutils literal notranslate"><span class="pre">1</span></code>，就返回<code class="docutils literal notranslate"><span class="pre">1</span></code>，否则返回<code class="docutils literal notranslate"><span class="pre">0</span></code>。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="o">|</span> <span class="mi">3</span> <span class="c1">// 3</span>
</pre></div>
</div>
<p>上面代码中，<code class="docutils literal notranslate"><span class="pre">0</span></code>和<code class="docutils literal notranslate"><span class="pre">3</span></code>的二进制形式分别是<code class="docutils literal notranslate"><span class="pre">00</span></code>和<code class="docutils literal notranslate"><span class="pre">11</span></code>，所以进行二进制或运算会得到<code class="docutils literal notranslate"><span class="pre">11</span></code>（即<code class="docutils literal notranslate"><span class="pre">3</span></code>）。</p>
<p>位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分。所以，将一个小数与<code class="docutils literal notranslate"><span class="pre">0</span></code>进行二进制或运算，等同于对该数去除小数部分，即取整数位。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mf">2.9</span> <span class="o">|</span> <span class="mi">0</span> <span class="c1">// 2</span>
<span class="o">-</span><span class="mf">2.9</span> <span class="o">|</span> <span class="mi">0</span> <span class="c1">// -2</span>
</pre></div>
</div>
<p>需要注意的是，这种取整方法不适用超过32位整数最大值<code class="docutils literal notranslate"><span class="pre">2147483647</span></code>的数。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mf">2147483649.4</span> <span class="o">|</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">// -2147483647</span>
</pre></div>
</div>
</div>
<div class="section" id="">
<span id="id24"></span><h3>二进制与运算符<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>二进制与运算符（<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>）的规则是逐位比较两个运算子，两个二进制位之中只要有一个位为<code class="docutils literal notranslate"><span class="pre">0</span></code>，就返回<code class="docutils literal notranslate"><span class="pre">0</span></code>，否则返回<code class="docutils literal notranslate"><span class="pre">1</span></code>。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="o">&amp;</span> <span class="mi">3</span> <span class="c1">// 0</span>
</pre></div>
</div>
<p>上面代码中，0（二进制<code class="docutils literal notranslate"><span class="pre">00</span></code>）和3（二进制<code class="docutils literal notranslate"><span class="pre">11</span></code>）进行二进制与运算会得到<code class="docutils literal notranslate"><span class="pre">00</span></code>（即<code class="docutils literal notranslate"><span class="pre">0</span></code>）。</p>
</div>
<div class="section" id="">
<span id="id25"></span><h3>二进制否运算符<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>二进制否运算符（<code class="docutils literal notranslate"><span class="pre">~</span></code>）将每个二进制位都变为相反值（<code class="docutils literal notranslate"><span class="pre">0</span></code>变为<code class="docutils literal notranslate"><span class="pre">1</span></code>，<code class="docutils literal notranslate"><span class="pre">1</span></code>变为<code class="docutils literal notranslate"><span class="pre">0</span></code>）。它的返回结果有时比较难理解，因为涉及到计算机内部的数值表示机制。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="o">~</span> <span class="mi">3</span> <span class="c1">// -4</span>
</pre></div>
</div>
<p>上面表达式对<code class="docutils literal notranslate"><span class="pre">3</span></code>进行二进制否运算，得到<code class="docutils literal notranslate"><span class="pre">-4</span></code>。之所以会有这样的结果，是因为位运算时，JavaScirpt 内部将所有的运算子都转为32位的二进制整数再进行运算。</p>
<p><code class="docutils literal notranslate"><span class="pre">3</span></code>的32位整数形式是<code class="docutils literal notranslate"><span class="pre">00000000000000000000000000000011</span></code>，二进制否运算以后得到<code class="docutils literal notranslate"><span class="pre">11111111111111111111111111111100</span></code>。由于第一位（符号位）是1，所以这个数是一个负数。JavaScript 内部采用补码形式表示负数，即需要将这个数减去1，再取一次反，然后加上负号，才能得到这个负数对应的10进制值。这个数减去1等于<code class="docutils literal notranslate"><span class="pre">11111111111111111111111111111011</span></code>，再取一次反得到<code class="docutils literal notranslate"><span class="pre">00000000000000000000000000000100</span></code>，再加上负号就是<code class="docutils literal notranslate"><span class="pre">-4</span></code>。考虑到这样的过程比较麻烦，可以简单记忆成，一个数与自身的取反值相加，等于-1。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="o">~</span> <span class="o">-</span><span class="mi">3</span> <span class="c1">// 2</span>
</pre></div>
</div>
<p>上面表达式可以这样算，<code class="docutils literal notranslate"><span class="pre">-3</span></code>的取反值等于<code class="docutils literal notranslate"><span class="pre">-1</span></code>减去<code class="docutils literal notranslate"><span class="pre">-3</span></code>，结果为<code class="docutils literal notranslate"><span class="pre">2</span></code>。</p>
<p>对一个整数连续两次二进制否运算，得到它自身。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="o">~~</span><span class="mi">3</span> <span class="c1">// 3</span>
</pre></div>
</div>
<p>所有的位运算都只对整数有效。二进制否运算遇到小数时，也会将小数部分舍去，只保留整数部分。所以，对一个小数连续进行两次二进制否运算，能达到取整效果。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="o">~~</span><span class="mf">2.9</span> <span class="c1">// 2</span>
<span class="o">~~</span><span class="mf">47.11</span> <span class="c1">// 47</span>
<span class="o">~~</span><span class="mf">1.9999</span> <span class="c1">// 1</span>
<span class="o">~~</span><span class="mi">3</span> <span class="c1">// 3</span>
</pre></div>
</div>
<p>使用二进制否运算取整，是所有取整方法中最快的一种。</p>
<p>对字符串进行二进制否运算，JavaScript 引擎会先调用<code class="docutils literal notranslate"><span class="pre">Number</span></code>函数，将字符串转为数值。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 相当于~Number(&#39;011&#39;)</span>
<span class="o">~</span><span class="s1">&#39;011&#39;</span>  <span class="c1">// -12</span>

<span class="c1">// 相当于~Number(&#39;42 cats&#39;)</span>
<span class="o">~</span><span class="s1">&#39;42 cats&#39;</span> <span class="c1">// -1</span>

<span class="c1">// 相当于~Number(&#39;0xcafebabe&#39;)</span>
<span class="o">~</span><span class="s1">&#39;0xcafebabe&#39;</span> <span class="c1">// 889275713</span>

<span class="c1">// 相当于~Number(&#39;deadbeef&#39;)</span>
<span class="o">~</span><span class="s1">&#39;deadbeef&#39;</span> <span class="c1">// -1</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Number</span></code>函数将字符串转为数值的规则，参见《数据的类型转换》一章。</p>
<p>对于其他类型的值，二进制否运算也是先用<code class="docutils literal notranslate"><span class="pre">Number</span></code>转为数值，然后再进行处理。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 相当于 ~Number([])</span>
<span class="o">~</span><span class="p">[]</span> <span class="c1">// -1</span>

<span class="c1">// 相当于 ~Number(NaN)</span>
<span class="o">~</span><span class="kc">NaN</span> <span class="c1">// -1</span>

<span class="c1">// 相当于 ~Number(null)</span>
<span class="o">~</span><span class="kc">null</span> <span class="c1">// -1</span>
</pre></div>
</div>
</div>
<div class="section" id="">
<span id="id26"></span><h3>异或运算<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>异或运算（<code class="docutils literal notranslate"><span class="pre">^</span></code>）在两个二进制位不同时返回<code class="docutils literal notranslate"><span class="pre">1</span></code>，相同时返回<code class="docutils literal notranslate"><span class="pre">0</span></code>。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="o">^</span> <span class="mi">3</span> <span class="c1">// 3</span>
</pre></div>
</div>
<p>上面表达式中，<code class="docutils literal notranslate"><span class="pre">0</span></code>（二进制<code class="docutils literal notranslate"><span class="pre">00</span></code>）与<code class="docutils literal notranslate"><span class="pre">3</span></code>（二进制<code class="docutils literal notranslate"><span class="pre">11</span></code>）进行异或运算，它们每一个二进制位都不同，所以得到<code class="docutils literal notranslate"><span class="pre">11</span></code>（即<code class="docutils literal notranslate"><span class="pre">3</span></code>）。</p>
<p>“异或运算”有一个特殊运用，连续对两个数<code class="docutils literal notranslate"><span class="pre">a</span></code>和<code class="docutils literal notranslate"><span class="pre">b</span></code>进行三次异或运算，<code class="docutils literal notranslate"><span class="pre">a^=b;</span> <span class="pre">b^=a;</span> <span class="pre">a^=b;</span></code>，可以<a class="reference external" href="http://en.wikipedia.org/wiki/XOR_swap_algorithm">互换</a>它们的值。这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>

<span class="nx">a</span> <span class="o">^=</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">b</span> <span class="o">^=</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">a</span> <span class="o">^=</span> <span class="nx">b</span><span class="p">;</span>

<span class="nx">a</span> <span class="c1">// 99</span>
<span class="nx">b</span> <span class="c1">// 10</span>
</pre></div>
</div>
<p>这是互换两个变量的值的最快方法。</p>
<p>异或运算也可以用来取整。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mf">12.9</span> <span class="o">^</span> <span class="mi">0</span> <span class="c1">// 12</span>
</pre></div>
</div>
</div>
<div class="section" id="">
<span id="id27"></span><h3>左移运算符<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>左移运算符（<code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>）表示将一个数的二进制值向左移动指定的位数，尾部补<code class="docutils literal notranslate"><span class="pre">0</span></code>，即乘以<code class="docutils literal notranslate"><span class="pre">2</span></code>的指定次方（最高位即符号位不参与移动）。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 4 的二进制形式为100，</span>
<span class="c1">// 左移一位为1000（即十进制的8）</span>
<span class="c1">// 相当于乘以2的1次方</span>
<span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
<span class="c1">// 8</span>

<span class="o">-</span><span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
<span class="c1">// -8</span>
</pre></div>
</div>
<p>上面代码中，<code class="docutils literal notranslate"><span class="pre">-4</span></code>左移一位得到<code class="docutils literal notranslate"><span class="pre">-8</span></code>，是因为<code class="docutils literal notranslate"><span class="pre">-4</span></code>的二进制形式是<code class="docutils literal notranslate"><span class="pre">11111111111111111111111111111100</span></code>，左移一位后得到<code class="docutils literal notranslate"><span class="pre">11111111111111111111111111111000</span></code>，该数转为十进制（减去1后取反，再加上负号）即为<code class="docutils literal notranslate"><span class="pre">-8</span></code>。</p>
<p>如果左移0位，就相当于将该数值转为32位整数，等同于取整，对于正数和负数都有效。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mf">13.5</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span>
<span class="c1">// 13</span>

<span class="o">-</span><span class="mf">13.5</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span>
<span class="c1">// -13</span>
</pre></div>
</div>
<p>左移运算符用于二进制数值非常方便。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">color</span> <span class="o">=</span> <span class="p">{</span><span class="nx">r</span><span class="o">:</span> <span class="mi">186</span><span class="p">,</span> <span class="nx">g</span><span class="o">:</span> <span class="mi">218</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">85</span><span class="p">};</span>

<span class="c1">// RGB to HEX</span>
<span class="c1">// (1 &lt;&lt; 24)的作用为保证结果是6位数</span>
<span class="kd">var</span> <span class="nx">rgb2hex</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">g</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s1">&#39;#&#39;</span> <span class="o">+</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nx">r</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nx">g</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="nx">b</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="c1">// 先转成十六进制，然后返回字符串</span>
    <span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>   <span class="c1">// 去除字符串的最高位，返回后面六个字符串</span>
<span class="p">}</span>

<span class="nx">rgb2hex</span><span class="p">(</span><span class="nx">color</span><span class="p">.</span><span class="nx">r</span><span class="p">,</span> <span class="nx">color</span><span class="p">.</span><span class="nx">g</span><span class="p">,</span> <span class="nx">color</span><span class="p">.</span><span class="nx">b</span><span class="p">)</span>
<span class="c1">// &quot;#bada55&quot;</span>
</pre></div>
</div>
<p>上面代码使用左移运算符，将颜色的 RGB 值转为 HEX 值。</p>
</div>
<div class="section" id="">
<span id="id28"></span><h3>右移运算符<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>右移运算符（<code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>）表示将一个数的二进制值向右移动指定的位数，头部补<code class="docutils literal notranslate"><span class="pre">0</span></code>，即除以<code class="docutils literal notranslate"><span class="pre">2</span></code>的指定次方（最高位即符号位不参与移动）。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mi">4</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
<span class="c1">// 2</span>
<span class="cm">/*</span>
<span class="cm">// 因为4的二进制形式为 00000000000000000000000000000100，</span>
<span class="cm">// 右移一位得到 00000000000000000000000000000010，</span>
<span class="cm">// 即为十进制的2</span>
<span class="cm">*/</span>

<span class="o">-</span><span class="mi">4</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
<span class="c1">// -2</span>
<span class="cm">/*</span>
<span class="cm">// 因为-4的二进制形式为 11111111111111111111111111111100，</span>
<span class="cm">// 右移一位，头部补1，得到 11111111111111111111111111111110,</span>
<span class="cm">// 即为十进制的-2</span>
<span class="cm">*/</span>
</pre></div>
</div>
<p>右移运算可以模拟 2 的整除运算。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mi">5</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
<span class="c1">// 2</span>
<span class="c1">// 相当于 5 / 2 = 2</span>

<span class="mi">21</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span>
<span class="c1">// 5</span>
<span class="c1">// 相当于 21 / 4 = 5</span>

<span class="mi">21</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span>
<span class="c1">// 2</span>
<span class="c1">// 相当于 21 / 8 = 2</span>

<span class="mi">21</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span>
<span class="c1">// 1</span>
<span class="c1">// 相当于 21 / 16 = 1</span>
</pre></div>
</div>
</div>
<div class="section" id="">
<span id="id29"></span><h3>带符号位的右移运算符<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>带符号位的右移运算符（<code class="docutils literal notranslate"><span class="pre">&gt;&gt;&gt;</span></code>）表示将一个数的二进制形式向右移动，包括符号位也参与移动，头部补<code class="docutils literal notranslate"><span class="pre">0</span></code>。所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（<code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>）完全一致，区别主要在于负数。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mi">4</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span>
<span class="c1">// 2</span>

<span class="o">-</span><span class="mi">4</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span>
<span class="c1">// 2147483646</span>
<span class="cm">/*</span>
<span class="cm">// 因为-4的二进制形式为11111111111111111111111111111100，</span>
<span class="cm">// 带符号位的右移一位，得到01111111111111111111111111111110，</span>
<span class="cm">// 即为十进制的2147483646。</span>
<span class="cm">*/</span>
</pre></div>
</div>
<p>这个运算实际上将一个值转为32位无符号整数。</p>
<p>查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">0</span> <span class="c1">// 4294967295</span>
</pre></div>
</div>
<p>上面代码表示，<code class="docutils literal notranslate"><span class="pre">-1</span></code>作为32位整数时，内部的储存形式使用无符号整数格式解读，值为 4294967295（即<code class="docutils literal notranslate"><span class="pre">(2^32)-1</span></code>，等于<code class="docutils literal notranslate"><span class="pre">11111111111111111111111111111111</span></code>）。</p>
</div>
<div class="section" id="">
<span id="id30"></span><h3>开关作用<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>位运算符可以用作设置对象属性的开关。</p>
<p>假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">FLAG_A</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 0001</span>
<span class="kd">var</span> <span class="nx">FLAG_B</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 0010</span>
<span class="kd">var</span> <span class="nx">FLAG_C</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// 0100</span>
<span class="kd">var</span> <span class="nx">FLAG_D</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="c1">// 1000</span>
</pre></div>
</div>
<p>上面代码设置 A、B、C、D 四个开关，每个开关分别占有一个二进制位。</p>
<p>然后，就可以用二进制与运算检验，当前设置是否打开了指定开关。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">flags</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// 二进制的0101</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">FLAG_C</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
<span class="c1">// 0101 &amp; 0100 =&gt; 0100 =&gt; true</span>
</pre></div>
</div>
<p>上面代码检验是否打开了开关<code class="docutils literal notranslate"><span class="pre">C</span></code>。如果打开，会返回<code class="docutils literal notranslate"><span class="pre">true</span></code>，否则返回<code class="docutils literal notranslate"><span class="pre">false</span></code>。</p>
<p>现在假设需要打开<code class="docutils literal notranslate"><span class="pre">A</span></code>、<code class="docutils literal notranslate"><span class="pre">B</span></code>、<code class="docutils literal notranslate"><span class="pre">D</span></code>三个开关，我们可以构造一个掩码变量。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">mask</span> <span class="o">=</span> <span class="nx">FLAG_A</span> <span class="o">|</span> <span class="nx">FLAG_B</span> <span class="o">|</span> <span class="nx">FLAG_D</span><span class="p">;</span>
<span class="c1">// 0001 | 0010 | 1000 =&gt; 1011</span>
</pre></div>
</div>
<p>上面代码对<code class="docutils literal notranslate"><span class="pre">A</span></code>、<code class="docutils literal notranslate"><span class="pre">B</span></code>、<code class="docutils literal notranslate"><span class="pre">D</span></code>三个变量进行二进制或运算，得到掩码值为二进制的<code class="docutils literal notranslate"><span class="pre">1011</span></code>。</p>
<p>有了掩码，二进制或运算可以确保打开指定的开关。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">flags</span> <span class="o">=</span> <span class="nx">flags</span> <span class="o">|</span> <span class="nx">mask</span><span class="p">;</span>
</pre></div>
</div>
<p>二进制与运算可以将当前设置中凡是与开关设置不一样的项，全部关闭。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">flags</span> <span class="o">=</span> <span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">mask</span><span class="p">;</span>
</pre></div>
</div>
<p>异或运算可以切换（toggle）当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">flags</span> <span class="o">=</span> <span class="nx">flags</span> <span class="o">^</span> <span class="nx">mask</span><span class="p">;</span>
</pre></div>
</div>
<p>二进制否运算可以翻转当前设置，即原设置为<code class="docutils literal notranslate"><span class="pre">0</span></code>，运算后变为<code class="docutils literal notranslate"><span class="pre">1</span></code>；原设置为<code class="docutils literal notranslate"><span class="pre">1</span></code>，运算后变为<code class="docutils literal notranslate"><span class="pre">0</span></code>。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">flags</span> <span class="o">=</span> <span class="o">~</span><span class="nx">flags</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="">
<span id="id31"></span><h2>其他运算符<a class="headerlink" href="#" title="永久链接至标题">¶</a></h2>
<div class="section" id="void">
<span id="void"></span><h3>void 运算符<a class="headerlink" href="#void" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">void</span></code>运算符的作用是执行一个表达式，然后不返回任何值，或者说返回<code class="docutils literal notranslate"><span class="pre">undefined</span></code>。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="k">void</span> <span class="mi">0</span> <span class="c1">// undefined</span>
<span class="k">void</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// undefined</span>
</pre></div>
</div>
<p>上面是<code class="docutils literal notranslate"><span class="pre">void</span></code>运算符的两种写法，都正确。建议采用后一种形式，即总是使用圆括号。因为<code class="docutils literal notranslate"><span class="pre">void</span></code>运算符的优先性很高，如果不使用括号，容易造成错误的结果。比如，<code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">4</span> <span class="pre">+</span> <span class="pre">7</span></code>实际上等同于<code class="docutils literal notranslate"><span class="pre">(void</span> <span class="pre">4)</span> <span class="pre">+</span> <span class="pre">7</span></code>。</p>
<p>下面是<code class="docutils literal notranslate"><span class="pre">void</span></code>运算符的一个例子。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="k">void</span> <span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">//undefined</span>
<span class="nx">x</span> <span class="c1">// 5</span>
</pre></div>
</div>
<p>这个运算符的主要用途是浏览器的书签工具（bookmarklet），以及在超级链接中插入代码防止网页跳转。</p>
<p>请看下面的代码。</p>
<div class="highlight-html notranslate"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hello World&#39;</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;http://example.com&quot;</span> <span class="na">onclick</span><span class="o">=</span><span class="s">&quot;f(); return false;&quot;</span><span class="p">&gt;</span>点击<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>上面代码中，点击链接后，会先执行<code class="docutils literal notranslate"><span class="pre">onclick</span></code>的代码，由于<code class="docutils literal notranslate"><span class="pre">onclick</span></code>返回<code class="docutils literal notranslate"><span class="pre">false</span></code>，所以浏览器不会跳转到 example.com。</p>
<p><code class="docutils literal notranslate"><span class="pre">void</span></code>运算符可以取代上面的写法。</p>
<div class="highlight-html notranslate"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;javascript: void(f())&quot;</span><span class="p">&gt;</span>文字<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>下面是一个更实际的例子，用户点击链接提交表单，但是不产生页面跳转。</p>
<div class="highlight-html notranslate"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;javascript: void(document.form.submit())&quot;</span><span class="p">&gt;</span>
  提交
<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="">
<span id="id32"></span><h3>逗号运算符<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>逗号运算符用于对两个表达式求值，并返回后一个表达式的值。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span> <span class="c1">// &quot;b&quot;</span>

<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="o">++</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="nx">x</span> <span class="c1">// 1</span>
<span class="nx">y</span> <span class="c1">// 10</span>
</pre></div>
</div>
<p>上面代码中，逗号运算符返回后一个表达式的值。</p>
</div>
</div>
<div class="section" id="">
<span id="id33"></span><h2>运算顺序<a class="headerlink" href="#" title="永久链接至标题">¶</a></h2>
<div class="section" id="">
<span id="id34"></span><h3>优先级<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>JavaScript 各种运算符的优先级别（Operator Precedence）是不一样的。优先级高的运算符先执行，优先级低的运算符后执行。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mi">4</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">6</span> <span class="c1">// 34</span>
</pre></div>
</div>
<p>上面的代码中，乘法运算符（<code class="docutils literal notranslate"><span class="pre">*</span></code>）的优先性高于加法运算符（<code class="docutils literal notranslate"><span class="pre">+</span></code>），所以先执行乘法，再执行加法，相当于下面这样。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="mi">4</span> <span class="o">+</span> <span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="mi">6</span><span class="p">)</span> <span class="c1">// 34</span>
</pre></div>
</div>
<p>如果多个运算符混写在一起，常常会导致令人困惑的代码。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>

<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="nx">x</span> <span class="o">:</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</pre></div>
</div>
<p>上面代码中，变量<code class="docutils literal notranslate"><span class="pre">y</span></code>的值就很难看出来，因为这个表达式涉及5个运算符，到底谁的优先级最高，实在不容易记住。</p>
<p>根据语言规格，这五个运算符的优先级从高到低依次为：小于等于（<code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>)、严格相等（<code class="docutils literal notranslate"><span class="pre">===</span></code>）、或（<code class="docutils literal notranslate"><span class="pre">||</span></code>）、三元（<code class="docutils literal notranslate"><span class="pre">?:</span></code>）、等号（<code class="docutils literal notranslate"><span class="pre">=</span></code>）。因此上面的表达式，实际的运算顺序如下。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="p">((</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">))</span> <span class="o">?</span> <span class="nx">x</span> <span class="o">:</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</pre></div>
</div>
<p>记住所有运算符的优先级，是非常难的，也是没有必要的。</p>
</div>
<div class="section" id="">
<span id="id35"></span><h3>圆括号的作用<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>圆括号（<code class="docutils literal notranslate"><span class="pre">()</span></code>）可以用来提高运算的优先级，因为它的优先级是最高的，即圆括号中的表达式会第一个运算。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="mi">6</span> <span class="c1">// 54</span>
</pre></div>
</div>
<p>上面代码中，由于使用了圆括号，加法会先于乘法执行。</p>
<p>运算符的优先级别十分繁杂，且都是硬性规定，因此建议总是使用圆括号，保证运算顺序清晰可读，这对代码的维护和除错至关重要。</p>
<p>顺便说一下，圆括号不是运算符，而是一种语法结构。它一共有两种用法：一种是把表达式放在圆括号之中，提升运算的优先级；另一种是跟在函数的后面，作用是调用函数。</p>
<p>注意，因为圆括号不是运算符，所以不具有求值作用，只改变运算的优先级。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<p>上面代码的第二行，如果圆括号具有求值作用，那么就会变成<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">=</span> <span class="pre">2</span></code>，这是会报错了。但是，上面的代码可以运行，这验证了圆括号只改变优先级，不会求值。</p>
<p>这也意味着，如果整个表达式都放在圆括号之中，那么不会有任何效果。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nx">exprssion</span><span class="p">)</span>
<span class="c1">// 等同于</span>
<span class="nx">expression</span>
</pre></div>
</div>
<p>函数放在圆括号中，会返回函数本身。如果圆括号紧跟在函数的后面，就表示调用函数。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="c1">// function f(){return 1;}</span>
<span class="nx">f</span><span class="p">()</span> <span class="c1">// 1</span>
</pre></div>
</div>
<p>上面代码中，函数放在圆括号之中会返回函数本身，圆括号跟在函数后面则是调用函数。</p>
<p>圆括号之中，只能放置表达式，如果将语句放在圆括号之中，就会报错。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">// SyntaxError: Unexpected token var</span>
</pre></div>
</div>
</div>
<div class="section" id="">
<span id="id36"></span><h3>左结合与右结合<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>对于优先级别相同的运算符，大多数情况，计算顺序总是从左到右，这叫做运算符的“左结合”（left-to-right associativity），即从左边开始计算。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">z</span>
</pre></div>
</div>
<p>上面代码先计算最左边的<code class="docutils literal notranslate"><span class="pre">x</span></code>与<code class="docutils literal notranslate"><span class="pre">y</span></code>的和，然后再计算与<code class="docutils literal notranslate"><span class="pre">z</span></code>的和。</p>
<p>但是少数运算符的计算顺序是从右到左，即从右边开始计算，这叫做运算符的“右结合”（right-to-left associativity）。其中，最主要的是赋值运算符（<code class="docutils literal notranslate"><span class="pre">=</span></code>）和三元条件运算符（<code class="docutils literal notranslate"><span class="pre">?:</span></code>）。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">w</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">z</span><span class="p">;</span>
<span class="nx">q</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">?</span> <span class="nx">b</span> <span class="o">:</span> <span class="nx">c</span> <span class="o">?</span> <span class="nx">d</span> <span class="o">:</span> <span class="nx">e</span> <span class="o">?</span> <span class="nx">f</span> <span class="o">:</span> <span class="nx">g</span><span class="p">;</span>
</pre></div>
</div>
<p>上面代码的运算结果，相当于下面的样子。</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">w</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">z</span><span class="p">));</span>
<span class="nx">q</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">?</span> <span class="nx">b</span> <span class="o">:</span> <span class="p">(</span><span class="nx">c</span> <span class="o">?</span> <span class="nx">d</span> <span class="o">:</span> <span class="p">(</span><span class="nx">e</span> <span class="o">?</span> <span class="nx">f</span> <span class="o">:</span> <span class="nx">g</span><span class="p">));</span>
</pre></div>
</div>
<p>上面的两行代码，各有三个等号运算符和三个三元运算符，都是先计算最右边的那个运算符。</p>
</div>
</div>
<div class="section" id="">
<span id="id37"></span><h2>参考链接<a class="headerlink" href="#" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>Michal Budzynski, <a class="reference external" href="http://michalbe.blogspot.co.uk/2013/03/javascript-less-known-parts-bitwise.html">JavaScript: The less known parts. Bitwise Operators</a></li>
<li>Axel Rauschmayer, <a class="reference external" href="http://www.2ality.com/2013/06/basic-javascript.html">Basic JavaScript for the impatient programmer</a></li>
<li>Mozilla Developer Network, <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators">Bitwise Operators</a></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="conversion.html" class="btn btn-neutral float-right" title="数据类型转换" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="function.html" class="btn btn-neutral" title="函数" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Vic Wang.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'beta',
            LANGUAGE:'zh',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/GA.js"></script>
      <script type="text/javascript" src="../_static/googleAnalysis.js"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>